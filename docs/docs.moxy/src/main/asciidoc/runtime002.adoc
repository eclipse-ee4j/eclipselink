///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2022 Oracle and/or its affiliates. All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Public License v. 2.0, which is available at
    http://www.eclipse.org/legal/epl-2.0.

    This Source Code may also be made available under the following Secondary
    Licenses when the conditions for such availability set forth in the
    Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
    version 2 with the GNU Classpath Exception, which is available at
    https://www.gnu.org/software/classpath/license.html.

    SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

///////////////////////////////////////////////////////////////////////////////
[[RUNTIME002]]
=== Bootstrapping

EclipseLink MOXy offers several options when creating your
`JAXBContext`. You have the option of bootstrapping from:

* A list of one or more JAXB-annotated classes
* A list of one or more EclipseLink XML bindings documents defining the
mappings for your Java classes
* A combination of classes and XML bindings
* A list of context paths
* A list of session names, referring to EclipseLink sessions defined in
`sessions.xml`

==== Using the JAXBContext API

The methods on `JAXBContext` (shown in link:#CACIIJCH[Example 2-1]) are
used to create new instances.

[[CACIIJCH]]

*_Example 2-1 JAXBContext Methods_*

[source,oac_no_warn]
----
public static JAXBContext newInstance(Class... classesToBeBound) throws JAXBException

public static JAXBContext newInstance(Class[] classesToBeBound, Map<String,?> properties) throws JAXBException

public static JAXBContext newInstance(String contextPath) throws JAXBException

public static JAXBContext newInstance(String contextPath, ClassLoader classLoader) throws JAXBException

public static JAXBContext newInstance(String contextPath, ClassLoader classLoader, Map<String,?> properties) throws JAXBException
----

`JAXBContext` accepts the following options:

* *classesToBeBound* – List of Java classes to be recognized by the new
`JAXBContext`
* *contextPath* – List of Java package names (or EclipseLink session
names) that contain mapped classes
* *classLoader* – The class loader used to locate the mapped classes
* *properties* – A map of additional properties.

The APIs in link:#CACIIJCH[Example 2-1] expect to find a
`jaxb.properties` file in your Java package/context path. For more
information see link:runtime001.htm#CACFEGHC["Specifying the EclipseLink
Runtime"].

[[CACGJHHB]]

==== Bootstrapping from Classes

If you have a collection of Java classes annotated with JAXB
annotations, you can provide a list of these classes directly:

[source,oac_no_warn]
----
JAXBContext context = JAXBContext.newInstance(Company.class, Employee.class);
----

Other classes that are reachable from the classes in the array (for
example, referenced classes, super class) will automatically be
recognized by the `JAXBContext`. Subclasses or classes marked as
`@``XmlTransient` will not be recognized.

[[CACGGBJG]]

==== Bootstrapping from a Context Path

Another way to bootstrap your `JAXBContext` is with a `String`, called
the _context path_. This is a colon-delimited list of package names
containing your mapped classes:

[source,oac_no_warn]
----
JAXBContext context = JAXBContext.newInstance("example");
----

Using this approach, there are a few different ways that EclipseLink
will discover your model classes:

* link:#CACJBEFE[Using a `jaxb.index` File]
* link:#CACGECEG[Using an ObjectFactory]
* link:#CACHAFIB[Using MetadataSource]

[[CACJBEFE]]

===== Using a `jaxb.index` File

The context path could contain a file named `jaxb.index`, which is a
simple text file containing the class names from the current package
that will be brought into the `JAXBContext`:

[source,oac_no_warn]
----
src/example/jaxb.index:
----

[[sthref12]]

*_Example 2-2 Sample jaxb.index File_*

[source,oac_no_warn]
----
Employee
PhoneNumber
----

Other classes that are reachable from the classes in list (for example,
referenced classes, super class) will automatically be recognized by the
`JAXBContext`. Subclasses or classes marked as `@XmlTransient` will not
be recognized.

[[CACGECEG]]

===== Using an ObjectFactory

The context path could also contain a class called `ObjectFactory`,
which is a special factory class that JAXB will look for. This class
contains `create()` methods for each of the types in your model.
Typically the `ObjectFactory` will be generated by the JAXB compiler,
but one can be written by hand as well.

[source,oac_no_warn]
----
src/example/ObjectFactory.java:
----

[[sthref13]]

*_Example 2-3 Sample ObjectFactory_*

[source,oac_no_warn]
----
@XmlRegistry
public class ObjectFactory {
private final static QName _Employee_QNAME = new QName("", "employee");
private final static QName _PhoneNumber_QNAME = new QName("", "phone-number");
public ObjectFactory() {
}
public EmployeeType createEmployeeType() {
return new EmployeeType();
}
@XmlElementDecl(namespace = "", name = "employee")
 public JAXBElement<EmployeeType> createEmployee(EmployeeType value) {
        return new JAXBElement<EmployeeType>(_Employee_QNAME, EmployeeType.class, null, value);
    }
     public PhoneNumberType createPhoneNumberType() {
        return new PhoneNumberType();
    }
 
    @XmlElementDecl(namespace = "", name = "phone-number")
    public JAXBElement<PhoneNumberType> createPhoneNumber(PhoneNumberType value) {
        return new JAXBElement<PhoneNumberType>(_PhoneNumber_QNAME, PhoneNumberType.class, null, value);
    }
 
}
----

[[CACHAFIB]]

===== Using MetadataSource

EclipseLink MOXy also has the ability to retrieve mapping information
from an implementation of EclipseLink's `MetadataSource`. Using this
approach, you are responsible for creating your own `XmlBindings`.

[[sthref14]]

*_Example 2-4 Sample Metadata Source_*

[source,oac_no_warn]
----
package org.eclipse.persistence.jaxb.metadata;
public interface MetadataSource {
 
    /**
     * @param properties – The properties passed in to create the JAXBContext
     * @param classLoader – The ClassLoader passed in to create the JAXBContext
     * 
     * @return the XmlBindings object representing the metadata
     */
    XmlBindings getXmlBindings(Map<String, ?> properties, ClassLoader classLoader);
 
}
----

For information on using a MetadataSource, see
xref:{relativedir}/runtime004.adoc#RUNTIME004["Using MetadataSource"].

==== Bootstrapping from EclipseLink XML Bindings

To have more control over how your classes will be mapped to XML, you
can bootstrap from an EclipseLink XML bindings document. Using this
approach, you can take advantage of EclipseLink's robust mappings
framework and customize how each complex type in XML maps to its Java
counterpart.

Links to the actual documents are passed in via the *properties*
parameter, using a special key,
`JAXBContextProperties.OXM_METADATA_SOURCE`:

[[sthref15]]

*_Example 2-5 Using an EclipseLink Bindings Document_*

[source,oac_no_warn]
----
InputStream iStream = myClassLoader.getResourceAsStream("example/xml-bindings.xml");
 
Map<String, Object> properties = new HashMap<String, Object>();
properties.put(JAXBContextProperties.OXM_METADATA_SOURCE, iStream);
 
JAXBContext context = JAXBContext.newInstance(new Class[]{ Customer.class }, properties);
----

For more information on the XML Bindings format, see
xref:{relativedir}/runtime003.adoc#RUNTIME003["Using XML Bindings"].

==== Combining Annotated Classes and XML Bindings

When bootstrapping from annotated classes, additional mapping
information can be provided with an EclipseLink XML bindings document.
For instance, you might annotate your model classes with JAXB-spec-only
annotations, and put your EclipseLink-specific mapping customizations
into an XML bindings document (negating the need to import EclipseLink
annotations in your model classes).

For example, review the annotated `Employee` class in
link:#CACHBAEJ[Example 2-6].

[[CACHBAEJ]]

*_Example 2-6 Sample Java Class_*

[source,oac_no_warn]
----
package example;
 
import jakarta.xml.bind.annotation.*;

@XmlRootElement

@XmlAccessorType(XmlAccessType.FIELD)
public class Employee {
   @XmlElement(name="phone-number")
   private PhoneNumber phoneNumber;
   ...
}
----

You can customize the `Employee` to use an EclipseLink XMLAdapter for
marshalling/unmarshalling `PhoneNumbers` by using the XML Bindings in
link:#CACJCGHC[Example 2-7].

[[CACJCGHC]]

*_Example 2-7 Using an XML Bindings Document_*

[source,oac_no_warn]
----
<?xml version="1.0" encoding="US-ASCII"?>
<xml-bindings xmlns="http://www.eclipse.org/eclipselink/xsds/persistence/oxm">
  <java-types>
    <java-type name="example.Employee">
      <java-attributes>
        <xml-element java-attribute="phoneNumber">
          <xml-java-type-adapter value="example.util.PhoneNumberProcessor"/>
        </xml-element>
      </java-attributes>
    </java-type>
  </java-types>
</xml-bindings>
----

Finally, pass both the list of annotated classes and the link to the XML
Bindings to the `JAXBContext`, as shown in link:#CACDDFDF[Example 2-8].

[[CACDDFDF]]

*_Example 2-8 Sample Application Code_*

[source,oac_no_warn]
----
InputStream iStream = myClassLoader.getResourceAsStream("example/xml-bindings.xml");
 Map<String, Object> properties = new HashMap<String, Object>();
properties.put(JAXBContextProperties.OXM_METADATA_SOURCE, iStream);
 
Class[] classes = new Class[] { Company.class, Employee.class };
JAXBContext context = JAXBContext.newInstance(classes, properties);
----
