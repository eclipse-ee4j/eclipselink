*TOC*
Special:Whatlinkshere_EclipseLink_Exception_Error_Reference_(ELUG)[Related
topics]

This section lists EclipseLink exceptions and provides numerical ranges
of their error codes. Each exception code corresponds to an exception
class and includes the following information:

* The exception number in the format of
`+EXCEPTION [ECLIPSELINK-+`[.codeinlineitalic]#`+XXXX+`#`+]+`
* A description of the problem, taken from the raised exception

== Descriptor Exceptions (1 – 202)

`+DescriptorException+` is a development exception that is raised when
insufficient information is provided to the descriptor. The message that
is returned includes the name of the descriptor or mapping that caused
the exception. If a mapping within the descriptor caused the error, then
the name and parameters of the mapping are part of the returned message,
as this exampledemonstrates.

Internal exception, mapping and descriptor appear only if EclipseLink
has enough information about the source of the problem to provide this
information.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+` `+INTERNAL EXCEPTION: Message+`
`+MAPPING: Database mapping+` `+DESCRIPTOR: Descriptor+`

[#Example A-1]## *_Descriptor Exception_*

`+EXCEPTION [ECLIPSELINK – 75]: org.eclipse.persistence.exceptions.DescriptorException+`
`+EXCEPTION DESCRIPTION: The reference class is not specified.+`

[.msg]#ECLIPSELINK-00001: The attribute [\{0}] is not declared as type
ValueHolderInterface, but its mapping uses indirection.# *Cause*:
attributeName is not declared as type ValueHolderInterface, but the
mapping uses indirection. The mapping is set to use indirection, but the
related attribute is not defined as type ValueHolderInterface. It is
raised on foreign reference mappings.

*Action*: If you want to use indirection on the mapping, change the
attribute to type ValueHolderInterface. Otherwise, change the mapping
associated with the attribute so that it does not use indirection.

[.msg]#ECLIPSELINK-00002: The attribute [\{0}] is declared as type
ValueHolderInterface, but its mapping does not use indirection.#
*Cause*: attributeName is declared as type ValueHolderInterface, but
EclipseLink is unable to use indirection. The attribute is defined to be
of type ValueHolderInterface, but the mapping is not set to use
indirection. It is raised on foreign reference mappings.

*Action*: If you do not want to use indirection on the mapping, change
the attribute so it is not of type ValueHolderInterface. Otherwise,
change the mapping associated with the attribute to use indirection.

[.msg]#ECLIPSELINK-00006: Attribute name is missing.# *Cause*: The
attribute name is missing or not specified in the mapping definition.

*Action*: Specify the attribute name in the mapping by calling the
method setAttributeName(String attributeName).

[.msg]#ECLIPSELINK-00007: The attribute [\{0}] should be of type Vector
(or a type that implements Map or Collection, if using Java 2).#
*Cause*: When using Java 2, the specified attributeName is not defined
as type vector, or a type that implements the Map or Collection
interface. This occurs in one-to-many mapping, many-to-many mapping, and
collection mapping when mapping is set not to use indirection, and the
attribute type is not declared.

*Action*: Declare the attribute to be of type java.util.Vector.

[.msg]#ECLIPSELINK-00008: The descriptor [\{0}] has been set to use
inheritance, but a class indicator field has not been defined. \{2}When
using inheritance, a class indicator field or class extraction method
must be set. \{2}Parent Descriptor: [\{1}]# *Cause*: The class indicator
field is defined, but the descriptor is set to use inheritance. When
using inheritance, a class indicator field or class extraction method
must be set. The class indicator field is used to create the right type
of domain object.

*Action*: Set either a class indicator field or class extraction method.

[.msg]#ECLIPSELINK-00009: This mapping does not have a direct field name
set.# *Cause*: The direct field name from the target table is not set in
the direct collection mapping.

*Action*: Specify the direct field name by calling the method
setDirectFieldName(String fieldName).

[.msg]#ECLIPSELINK-00010: This mapping does not have a field name set.#
*Cause*: The field name is not set in the mapping. It is raised from
direct to field mapping, array mapping, and structure mapping.

*Action*: Specify the field name by calling the method
setFieldName(String fieldName).

[.msg]#ECLIPSELINK-00011: The foreign key information for this mapping
is defined incorrectly.# *Cause*: One-to-one mapping foreign key is
defined incorrectly. Multiple foreign key fields were set for one-to-one
mapping by calling the method setForeignKeyFieldName(String fieldName).

*Action*: Use the method addForeignKeyFieldName(String
sourceForeignKeyName, String targetPrimaryKeyFieldName) to add multiple
foreign key fields.

[.msg]#ECLIPSELINK-00012: Descriptors must use an identity map in order
to use the "`Check Cache`" existence checking option.# *Cause*: The
descriptor has been set not to use identity map, but the existence
checking is set to be performed on identity map: the descriptor must use
an identity map to use the Check cache does exist option.

*Action*: Either use identity map, or set the existence checking to some
other option.

[.msg]#ECLIPSELINK-00013: The instance variable [\{0}] in the object
[\{1}] is inaccessible.# *Cause*: EclipseLink is unable to access the
attributeName instance variable in object objectName. The instance
variable in the domain object is not accessible. This exception is
raised when EclipseLink tries to access the instance variable using the
java.lang.reflect Java package. The error is a purely Java exception,
and EclipseLink wraps only the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00014: Problem in cloning the object [\{0}]. The
clone method [\{1}] is not accessible.# *Cause*: EclipseLink is unable
to clone the object domainObject because the clone method methodName is
not accessible. The method name specified using
useCloneCopyPolicy(String cloneMethodName) or the clone() method to
create the clone on the domain object, is not accessible by EclipseLink
using Java reflection. The error is a purely Java exception, and
EclipseLink wraps only the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00015: This class does not define a default
constructor, which EclipseLink requires.# *Cause*: The domain class does
not define a public default constructor, which EclipseLink needs to
create new instances of the domain class.

*Action*: Define a public default constructor or use a different
instantiation policy.

[.msg]#ECLIPSELINK-00016: The descriptor callback method [\{0}], with
parameter (DescriptorEvent), is inaccessible.# *Cause*: The descriptor
callback method eventMethodName with DescriptorEvent as an argument is
not accessible. This exception is raised when EclipseLink tries to
access the event method using Java reflection. The error is a purely
Java exception, and EclipseLink wraps only the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00017: Trying to access the method [\{0}] on the
object [\{1}]. The underlying method is inaccessible.# *Cause*: Attempt
to invoke inaccessible methodName on the object objectName. The
underlying getter method to access an attribute in the domain object is
not accessible. This exception is raised when EclipseLink tries to
access an attribute through a method using the java.lang.reflect Java
package. The error is a purely Java exception, and EclipseLink wraps
only the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00018: Illegal method access in a Transformation
mapping using a ValueHolder.# *Cause*: The method used by the
transformation mapping using a value holder is invalid. This exception
is raised when EclipseLink tries to access the method using Java
reflection. The problem occurs when the method base valueholder is
instantiated.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00019: Illegal access while invoking the attribute
method on a Transformation mapping. The underlying method is
inaccessible.# *Cause*: On transformation mapping, the underlying
attribute method that is used to retrieve values from the database row
while reading the transformation mapped attribute is not accessible.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00020: The method [\{0}] is inaccessible.# *Cause*:
On transformation mapping, the method methodName that is used to
retrieve value from the object while writing the transformation mapped
attribute is not accessible. The error is a purely Java exception, and
EclipseLink wraps only the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00021: Problem in extracting class from row [\{0}].
The static method [\{1}], with parameter (DatabaseRow), is not
accessible.# *Cause*: EclipseLink is unable to extract data row, because
EclipseLink cannot access the row specified in the databaseRow argument
of the method. The method to extract class from row on the domain object
is not accessible. The error is a purely Java exception, and EclipseLink
wraps only the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00022: Problem in creating new instance. The creation
method [\{0}] is not accessible.# *Cause*: EclipseLink is unable to
create a new instance, because the method methodName that creates
instances on the domain class is not accessible. The error is a purely
Java exception, and EclipseLink wraps only the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00023: The descriptor callback method [\{0}], with
parameter (Session), is inaccessible.# *Cause*: The descriptor callback
method eventMethodName with Session as an argument is inaccessible. This
exception is raised when EclipseLink tries to access the event method
using Java reflection. The error is a purely Java exception, and
EclipseLink wraps only the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00024: The instance variable [\{0}] in the object
[\{1}] is inaccessible. \{3}Argument: [\{2}]# *Cause*: The attributeName
instance variable in the object objectName is not accessible through
Java reflection. The error is raised by Java, and EclipseLink wraps only
the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00025: The method [\{0}] with argument [\{1}] is not
accessible.# *Cause*: EclipseLink is unable to invoke a method
setMethodName on the object with parameter parameter. The attribute’s
set accessor method is not accessible through Java reflection. The error
is raised by Java and EclipseLink wraps only the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00026: Trying to get value for instance variable
[\{0}] of type [\{1}] from the object [\{2}]. The specified object is
not an instance of the class or interface declaring the underlying
field.# *Cause*: EclipseLink is unable to get a value for an instance
variable attributeName of type typeName from the object. The specified
object is not an instance of the class or interface declaring the
underlying field. An object is accessed to get the value of an instance
variable that does not exist.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00027: Trying to invoke the method [\{0}] on the
object [\{1}]. The number of actual and formal parameters differs, or an
unwrapping conversion has failed.# *Cause*: EclipseLink is unable to
invoke method methodName on the object objectName. The get accessor
method declaration on the domain object differs from the one that is
defined. The number of actual and formal parameters differ, or an
unwrapping conversion has failed.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00028: Illegal argument while instantiating a
method-based proxy in a Transformation mapping.# *Cause*: The method
that the method-based proxy uses in a transformation mapping is
receiving invalid arguments when the valueholder is being instantiated.
This exception is raised when EclipseLink tries to access the method
using the java.lang.reflect Java package.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00029: The number of actual and formal parameters
differs, or an unwrapping conversion has failed.# *Cause*: The number of
actual and formal parameters differs, or an unwrapping conversion has
failed. On transformation mapping, the method used to retrieve values
from the database row while reading the transformation mapped attribute
is getting an invalid argument.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00030: The number of actual and formal parameters
differs for method [\{0}], or an unwrapping conversion has failed.#
*Cause*: The number of actual and formal parameters differs for method
methodName, or an unwrapping conversion has failed. On transformation
mapping, the method used to retrieve value from the object while writing
the transformation mapped attribute is getting an invalid argument. The
error is a purely Java exception, and EclipseLink wraps only the
reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00031: The number of actual and formal parameters for
the descriptor callback method [\{0}] differs, or an unwrapping
conversion has failed.# *Cause*: The number of actual and formal
parameters for the descriptor callback method eventMethodName differs,
or an unwrapping conversion has failed. The callback event method is
invoked with an invalid argument. This exception is raised when
EclipseLink tries to invoke the event method using Java reflection. The
error is a purely Java exception, and EclipseLink wraps only the
reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00032: Trying to set value [\{0}] for instance
variable [\{1}] of type [\{2}] in the object. The specified object is
not an instance of the class or interface declaring the underlying
field, or an unwrapping conversion has failed.# *Cause*: An invalid
value is being assigned to the attribute instance variable. EclipseLink
is unable to set a value for an instance variable attributeName of type
typeName in the object. The specified object is not an instance of the
class or interface that is declaring the underlying field, or an
unwrapping conversion has failed. EclipseLink assigns value by using
Java reflection. Java raises the error and EclipseLink wraps only the
reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00033: Trying to invoke [\{0}] on the object [\{1}].
The number of actual and formal parameters differs, or an unwrapping
conversion has failed.# *Cause*: An illegal argument is being passed to
the attribute’s set accessor method. EclipseLink is unable to invoke
method setMethodName on the object. The number of actual and formal
parameters differs, or an unwrapping conversion has failed. Java raises
the error and EclipseLink wraps only the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00034: This class does not define a public default
constructor, or the constructor raised an exception.# *Cause*: The class
does not define a public default constructor, or the constructor raised
an exception. This error occurs when you invoke the default constructor
for the domain object to create a new instance of the object while
building new domain objects if:The class represents an abstract class,
an interface, an array class, a primitive type, or void.The
instantiation fails for some other reason. Java raises the error and
EclipseLink wraps only the reflection exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00035: Invalid event.# *Cause*: Applications should
never encounter this exception. This exception usually occurs at the
time of developing EclipseLink, although in cases, where you write new
mapping, it is possible to get this exception. In direct collection
mapping and many-to-many mapping, the target table and relational table
are populated at the end of the commit process, and if a data
modification event is sent to any other mapping, then this exception is
raised.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-00036: Invalid event code [\{0}].# *Cause*: An
application should never encounter this exception. This exception
usually occurs at the time of developing EclipseLink, although in cases,
where you write new mappings, it is possible to get this exception. In
direct collection mapping and many-to-many mapping, the target table and
relational table are populated at the end of the commit process, and if
a data modification event is sent to these two mappings with wrong event
code, then this exception is raised.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-00037: Invalid descriptor event code [\{0}].#
*Cause*: An application should never encounter this exception. This
exception usually occurs at the time of developing EclipseLink. The
exception means that the descriptor event manager does not support the
event code passed in the event.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-00038: Identity map constructor failed because an
invalid identity map was specified.# *Cause*: The identity map
constructor failed because an invalid identity map was specified. The
identity map class given in the descriptor cannot be instantiated. The
exception is a Java exception that is raised by a Java reflection when
EclipseLink instantiates the identity map class. EclipseLink wraps only
the Java exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00039: This descriptor does not specify a Java
class.# *Cause*: The descriptor does not define a Java class. The Java
class is not specified in the descriptor.

*Action*: Specify the Java class.

[.msg]#ECLIPSELINK-00040: Descriptor is missing for [\{0}]. It was
probably not added to the Session.# *Cause*: A descriptor for the
referenced interface is not added to the session.

*Action*: Add that descriptor to the session.

[.msg]#ECLIPSELINK-00041: A non-read-only mapping must be defined for
the sequence number field.# *Cause*: A non-read-only mapping is not
defined for the sequence number field. A mapping is required so that
EclipseLink can put and extract values for the primary key.

*Action*: Define a mapping.

[.msg]#ECLIPSELINK-00043: Missing class for indicator field value [\{0}]
of type [\{1}].# *Cause*: EclipseLink is missing the class for indicator
field value classFieldValue of type type. There was no class entry found
in the inheritance policy for the indicator field value that was read
from the database. It is likely that the method addClassIndicator(Class
class, Object typeValue) was not called for the field value. The class
and typeValue are stored in a hash table, and later the class is
extracted from the hash table by passing typeValue as a key. Because
Integer(1) is not equivalent to Float(1), this exception occurs when the
type of typeValue is incorrectly specified.

*Action*: Verify the descriptor.

[.msg]#ECLIPSELINK-00044: Missing class indicator field from database
row [\{0}].# *Cause*: The class indicator field is missing from the
database row that was read from the database. This is performed in the
inheritance model where after reading rows from the database, child
domain objects are to be constructed depending upon the type indicator
values.

*Action*: Verify the printed row for correct spelling.

[.msg]#ECLIPSELINK-00045: Missing mapping for field [\{0}].# *Cause*:
EclipseLink is missing a mapping for field; a mapping for the field is
not specified.

*Action*: Define a mapping for the field.

[.msg]#ECLIPSELINK-00046: There should be one non-read-only mapping
defined for the primary key field [\{0}].# *Cause*: A mapping for the
primary key is not specified. There should be one non-read-only mapping
defined for the primary key field.

*Action*: Define a mapping for the primary key.

[.msg]#ECLIPSELINK-00047: The multiple table primary key mapping must be
specified when a custom multiple table join is used.# *Cause*: The
multiple table primary key mapping is not specified when a custom
multiple table join is used. If multiple tables are specified in the
descriptor and the join expression is customized, then the primary keys
for all the tables must be specified. If the primary keys are not
specified, then the exception occurs.

*Action*: Call the method addMultipleTablePrimaryKeyFieldName(String
fieldNameInPrimaryTable, String fieldNameInSecondaryTable) on the
descriptor to set the primary keys.

[.msg]#ECLIPSELINK-00048: Multiple writable mappings exist for the field
[\{0}]. Only one may be defined as writable, all others must be
specified read-only.# *Cause*: Multiple writable mappings for the field
fieldName are defined in the descriptor. Exactly one must be defined as
writable; the others must be specified as read-only. When multiple write
mappings are defined for the field, EclipseLink is unable to choose the
appropriate mapping for writing the value of the field in the database
row. Therefore, the exception is raised during the validation process of
descriptors. The most common cause of this problem is when the field has
direct-to-field mapping, as well as one-to-one mapping. In this case,
the one-to-one mapping must either be read-only or a target foreign key
reference.

*Action*: Make one of those mappings read-only.

[.msg]#ECLIPSELINK-00049: An attribute transformation method name is not
specified for this mapping.# *Cause*: The attribute transformation
method name in the transformation mapping is not specified. This method
is invoked internally by EclipseLink to retrieve value to store in the
domain object.

*Action*: Define a method and set the method name on the mapping by
calling the method setAttributeTransformation(String methodName).

[.msg]#ECLIPSELINK-00050: A field name is not set for this mapping.#
*Cause*: No field name is specified in direct-to-field mapping.

*Action*: Set the field by calling setFieldName(String fieldName).

[.msg]#ECLIPSELINK-00051: No foreign keys have been specified for this
mapping.# *Cause*: Neither the selection criteria nor the foreign keys
were specified on one-to-one mapping. If the selection criterion is not
specified, then EclipseLink tries to build one from the foreign keys
specified in the mapping.

*Action*: Specify the fields.

[.msg]#ECLIPSELINK-00052: No reference key has been specified for this
mapping.# *Cause*: No query key named queryKey is found in descriptor.
No reference key from the target table is specified on direct collection
mapping.

*Action*: Specify the fields by calling the method
setReferenceKeyFieldName(String fieldName).

[.msg]#ECLIPSELINK-00053: The relation table name is not set for this
mapping.# *Cause*: The relation table name is not set in this
many-to-many mapping.

*Action*: Set the relation table name by calling the method
setRelationTableName(String tableName).

[.msg]#ECLIPSELINK-00054: There are no source relation keys specified
for this mapping.# *Cause*: There are no source relation keys specified
in this many-to-many mapping.

*Action*: Add source relation keys to the mapping.

[.msg]#ECLIPSELINK-00055: The descriptor callback method [\{0}] cannot
be found. It must take a Session or a DescriptorEvent as its argument.#
*Cause*: EclipseLink cannot find the descriptor callback method on the
domain class. It must take a Session or a DescriptorEvent as its
argument. EclipseLink tries to invoke the method using Java reflection.
It is a Java exception and EclipseLink is wrapping only the main
exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00056: The method [\{0}] with parameters (Record) or
(Record, Session) is not found.# *Cause*: EclipseLink cannot find the
method methodName(Record databaseRow) or methodName(Record databaseRow,
Session session). EclipseLink wraps the Java reflection exception that
is caused when the method is being created from the method name. This
method is set by calling setAttributeMethodName(String aMethodName).

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00057: Inaccessible constructor.# *Cause*: The
constructor is inaccessible to EclipseLink. EclipseLink wraps the Java
reflection exception that is caused when it is creating a new instance
of the domain.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00058: The method [\{0}] with parameters () or
(Session) not found.# *Cause*: EclipseLink failed to find a method with
signature methodName() or
methodName(org.eclipse.persistence.sessions.Session). EclipseLink wraps
the Java reflection exception that was raised by its attempt to create a
Method type (java.lang.reflect) from the method names in the
transformation mapping.

*Action*: Ensure that the method methodName is defined on the domain
class that owns the attribute mapped by the transformation mapping.

[.msg]#ECLIPSELINK-00059: The instance variable [\{0}] is not defined in
the domain class [\{1}], or it is not accessible.# *Cause*: The instance
variable attributeName is not defined in the domain class, or it is not
accessible. EclipseLink wraps the Java reflection exception that is
caused when it is creating a Field type (java.lang.reflect.Field) from
the attribute name.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00060: The method [\{0}] or [\{1}] is not defined in
the object [\{2}].# *Cause*: The method setMethodName or getMethodName
is not defined for the attribute in the domain class javaClassName, or
it is not accessible. EclipseLink wraps the Java reflection exception
that is caused when it is creating a Method type from the method name.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00061: The static class extraction method [\{0}],
with parameter (Record), does not exist, or is not accessible.# *Cause*:
The static class extraction method methodName(Record databaseRow) does
not exist, or is not accessible. A Java reflection exception wrapped in
an EclipseLink exception is raised when a class extraction method is
being created from the method name in the inheritance policy.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00062: The clone method [\{0}], with no parameters,
does not exist, or is not accessible.# *Cause*: The clone method
methodName() does not exist, or is not accessible. A Java reflection
exception wrapped in an EclipseLink exception is raised when a method to
create clones is being created from the method name in the copy policy.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00063: The instance creation method [\{0}], with no
parameters, does not exist, or is not accessible.# *Cause*: The instance
creation method methodName() does not exist, or is not accessible. A
Java reflection exception wrapped in an EclipseLink exception is raised
when a method to create the new instance is being created from the
method name in the instantiation policy.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00064: No target foreign keys have been specified for
this mapping.# *Cause*: The foreign keys in the target table are not
specified in one-to-many mappings. These fields are not required if a
selection criterion is given in the mapping, but otherwise they must be
specified.

*Action*: Set target foreign keys or selection criteria.

[.msg]#ECLIPSELINK-00065: No target relation keys have been specified
for this mapping.# *Cause*: There are no target relation keys specified
in many-to-many mappings.

*Action*: Call method addTargetRelationKeyFieldName(String
targetRelationKeyFieldName, String targetPrimaryKeyFieldName) to set the
fields.

[.msg]#ECLIPSELINK-00066: Could not deserialize object from byte array.#
*Cause*: Attempt to deserialize an object from the byte array that is
read from the database. The exception is raised when the serialized
object mapping is converting the byte array into an object.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00067: Could not serialize object into byte array.#
*Cause*: Attempt to serialize an object into a byte array. The exception
is raised when a serialized object mapping is converting the object into
a byte array.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00068: The value of an aggregate in object [\{0}] is
null. Null values not allowed for Aggregate mappings unless "`Allow
Null`" is specified.# *Cause*: The value of the aggregate in the source
object object is null. Null values are not allowed for aggregate
mappings unless allow null is specified in the aggregate mapping.

*Action*: Call the mapping method allowNull. Provide parameters only if
you are making a distinction between foo() and foo(integer).

[.msg]#ECLIPSELINK-00069: A NullPointerException was thrown while
extracting a value from the instance variable [\{0}] in the object
[\{1}].# *Cause*: An object is accessed to get the value of an instance
variable through Java reflection. This exception is raised only on some
JVMs.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00070: A NullPointerException was thrown while
extracting a value through the method [\{0}] in the object [\{1}].#
*Cause*: The getter method is invoked to get the value of an attribute
through Java reflection. This exception is raised only on some JVM.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00071: A NullPointerException was thrown while
setting the value of the instance variable [\{0}] to the value [\{1}].#
*Cause*: A NullPointerException has been raised while setting the value
of the attributeName instance variable in the object to value. An object
is accessed to set the value of an instance variable through Java
reflection. This exception is raised only on some JVMs.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00072: A NullPointerException was thrown while
setting a value through the method [\{0}] with argument [\{1}].#
*Cause*: A NullPointerException has been raised while setting the value
through setMethodName method in the object with an argument argument.
The set accessor method is invoked to set the value of an attribute
through Java reflection. This exception is raised only on some JVMs.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00073: Cannot find descriptor for parent class
[\{0}].# *Cause*: EclipseLink is unable to find the descriptor for the
parent class. The descriptor of a subclass has no parent descriptor.

*Action*: The method setParentClass(Class parentClass) must be called on
the subclass descriptor.

[.msg]#ECLIPSELINK-00074: The primary key fields are not set for this
descriptor.# *Cause*: The primary key fields are not set for this
descriptor.

*Action*: Add primary key field names using method
setPrimaryKeyFieldName(String fieldName).

[.msg]#ECLIPSELINK-00075: The reference class is not specified for this
descriptor.# *Cause*: The reference class is not specified in the
foreign reference mapping.

*Action*: Set the reference class by calling the method
setReferenceClass(Class aClass).

[.msg]#ECLIPSELINK-00077: The reference descriptor for [\{0}] should be
set to be an Aggregate descriptor.# *Cause*: The referenced descriptor
for class className is not set to an aggregate descriptor. An aggregate
mapping should always reference a descriptor that is aggregate.

*Action*: Call the method descriptorIsAggregate on the referenced
descriptor.

[.msg]#ECLIPSELINK-00078: The reference field [\{0}] for this mapping
must exist in the reference table.# *Cause*: The table for the reference
field is not the reference table. If the reference field name that is
specified in the direct collection mapping is qualified with the table
name, then the table name should match the reference table name.

*Action*: Qualify the field with the proper name, or change the
reference table name.

[.msg]#ECLIPSELINK-00079: The reference table is not specified for this
mapping.# *Cause*: The reference table name in the direct collection
mapping is not specified.

*Action*: Use the method setReferenceTableName(String tableName) on the
mapping to set the table name.

[.msg]#ECLIPSELINK-00080: The relation key field [\{0}] for this mapping
must exist in the relation table.# *Cause*: The table for the relation
key field is not the relation table. If the source and target relation
fields names that are specified in the many-to-many mapping are
qualified with the table name, then the table name should match the
relation table name.

*Action*: Qualify the field with the proper name, or change the relation
table name.

[.msg]#ECLIPSELINK-00081: The method [\{0}] should return the type of
the mapped attribute, not void.# *Cause*: The method attributeMethodName
that is specified in the transformation mapping does not have a return
type set in the attribute, as it should because this method is used to
extract value from the database row.

*Action*: Verify the method and make appropriate changes.

[.msg]#ECLIPSELINK-00082: The descriptor callback method [\{0}], with
parameter (DescriptorEvent), is not accessible.# *Cause*: The descriptor
callback method with DescriptorEvent as an argument is not accessible.
Java raises a security exception when a Method type is created from the
method name using Java reflection. The method is a descriptor event
callback on the domain object that takes DescriptorEvent as its
parameter.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00083: The descriptor callback method [\{0}], with
parameter (Session), is not accessible.# *Cause*: The descriptor
callback method with Session as an argument is not accessible. Java
raises a security exception when a Method type is created from the
method name using Java reflection. The method is a descriptor event
callback on the domain object, which takes class and session as its
parameters.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00084: The method [\{0}], with parameters (Record) or
(Record, Session), is not accessible.# *Cause*: Access to the method
methodName(Record databaseRow) or methodName(Record databaseRow, Session
session) has been denied. Java raises a security exception when a Method
type is created from the attribute method name using Java reflection.
The attribute method that is specified in the transformation mapping is
used to extract value from the database row and set by calling
setAttributeTransformation(String methodName).

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00085: The method [\{0}], with parameters () or
(Session), is not accessible.# *Cause*: EclipseLink failed to find a
method with signature methodName() or
methodName(org.eclipse.persistence.sessions.Session). Java raises a
security exception when a Method type is created from the method name
using Java reflection. These are the methods that extract the field
value from the domain object in the transformation mapping.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00086: The instance variable [\{0}] in the class
[\{1}] is not accessible.# *Cause*: Access to the instance variable
attributeName in the class javaClassName is denied. Java raises a
security exception when creating a Field type from the given attribute
name using Java reflection.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00087: The methods [\{0}], [\{1}] in the object
[\{2}] are not accessible# *Cause*: The methods setMethodName and
getMethodName in the object javaClassName are inaccessible. Java raises
a security exception when creating a Method type from the given
attribute accessor method name using Java reflection.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00088: The static class extraction method [\{0}],
with parameter (Record), is not accessible.# *Cause*: The static class
extraction method methodName(Record databaseRow) is not accessible. Java
raises a security exception when creating a Method type from the given
class extraction method name using Java reflection. The method is used
to extract the class from the database row in the inheritance policy.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00089: The clone method [\{0}], with no parameters,
is not accessible.# *Cause*: The clone method methodName() is
inaccessible. Using ClassDescriptor method useCloneCopyPolicy
(java.lang.String methodName), you can specify that the creation of
clones within a unit of work is done by sending the methodName method to
the original object. If the clone method methodName with no arguments is
inaccessible (your application does not have sufficient privileges to
call the method), Java raises a security exception when reflectively
accessing the method with the given method name using the
java.lang.reflect Java package.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00090: The instance creation method [\{0}], with no
parameters, is not accessible.# *Cause*: The instance creation method
methodName() is inaccessible. Using any of the ClassDescriptor methods
useFactoryInstantiationPolicy (java.lang.Class factoryClass,
java.lang.String methodName), useFactoryInstantiationPolicy
(java.lang.Class factoryClass, java.lang.String methodName,
java.lang.String factoryMethodName), useFactoryInstantiationPolicy
(java.lang.Object factory, java.lang.String methodName), or
useMethodInstantiationPolicy(java.lang.String staticMethodName), you can
specify how new instances are created. If any of the methods or factory
methods are inaccessible (your application does not have sufficient
privileges to call the method), Java raises a security exception when
reflectively accessing the method with the given method name using the
java.lang.reflect Java package.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00091: To use sequence-generated IDs, both the
"`Sequence Number Name`" and "`Sequence Number Field Name`" properties
must be set for this descriptor.# *Cause*: Either the sequenceNumberName
or the sequenceNumberFieldName property is not set. To use
sequence-generated IDs, both the sequenceNumberName and
sequenceNumberFieldName properties must be set for the descriptor.

*Action*: To use sequence-generated IDs, set both the sequence number
name and field name properties.

[.msg]#ECLIPSELINK-00092: The size of the target’’s primary key does not
match the size of the foreign key.# *Cause*: The size of the primary
keys on the target table does not match the size of the foreign keys on
the source in one-to-one mapping.

*Action*: Verify the mapping and the reference descriptor’s primary
keys.

[.msg]#ECLIPSELINK-00093: The table [\{0}] is not present in this
descriptor.# *Cause*: The table tableName is not present in the
descriptor.

*Action*: Verify the qualified field names that are specified in the
mappings and descriptor so that any fields that are qualified with the
table name reference the correct table.

[.msg]#ECLIPSELINK-00094: Descriptors must have a table name defined.#
*Cause*: No table is specified in the descriptor. The descriptor must
have a table name defined.

*Action*: Call the method addTableName(String tableName) or
setTableName(String tableName) to set the tables on the descriptor.

[.msg]#ECLIPSELINK-00096: The number of target keys does not match the
number of source keys.# *Cause*: The size of the foreign keys on the
target table does not match the size of the source keys on the source
table in the one-to-many mapping.

*Action*: Verify the mapping.

[.msg]#ECLIPSELINK-00097: Problem cloning the object [\{0}]. The clone
method [\{0}] triggered an exception.# *Cause*: EclipseLink has
encountered a problem in cloning the object domainObject clone method.
The methodName triggered an exception. Java raises this exception when
the cloned object is invoked while the object is being cloned. The clone
method is specified on the copy policy that is usually invoked to create
clones in unit of work.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00098: The underlying descriptor callback method
[\{0}], with parameter (DescriptorEvent), triggered an exception.#
*Cause*: A descriptor callback method eventMethodName(DescriptorEvent
event) is not accessible. The exception occurs when the descriptor event
method is invoked using Java reflection.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00099: The method [\{0}] on the object [\{1}]
triggered an exception.# *Cause*: The method methodName on the object
objectName is throwing an exception. Java is throwing an exception while
getting an attribute value from the object through a method accessor.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00100: A method has triggered an exception.# *Cause*:
A method has raised an exception. Java raises this exception while
instantiating a method based proxy and instantiating transformation
mapping.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00101: The underlying method triggered an exception.#
*Cause*: The underlying method raises an exception. Java is throwing an
exception while invoking an attribute transformation method on
transformation mapping. The method is invoked to extract value from the
database row to set into the domain object.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00102: The method [\{0}] triggered an exception.#
*Cause*: The method methodName is throwing an exception. Java is
throwing exception while invoking field transformation method on
transformation mapping. The method is invoked to extract value from the
domain object to set into the database row.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00103: Problem in extracting class from row [\{0}],
using static method [\{1}], with parameter (DatabaseRow). An exception
was triggered.# *Cause*: EclipseLink encountered a problem extracting
the class type from row rowName while invoking a class extraction
method.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00104: Problem in creating new instance using
creation method [\{0}]. The creation method triggered an exception.#
*Cause*: EclipseLink is unable to create a new instance. The creation
method methodName caused an exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00105: The underlying descriptor callback method
[\{0}], with parameter (Session), triggered an exception.# *Cause*: The
underlying descriptor callback method eventMethodName(Session session)
raises an exception. Java is throwing an exception while invoking a
descriptor event method that takes a session as its parameter.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00106: The method [\{0}] on the object is throwing an
exception. \{2}Argument: [\{1}]# *Cause*: The method setMethodName on
the object raises an exception. Java is throwing an exception while
invoking a set accessor method on the domain object to set an attribute
value into the domain object.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00108: Cannot find value in class indicator mapping
in parent descriptor [\{0}].# *Cause*: The indicator value is not found
in the class indicator mapping in the parent descriptor for the class.

*Action*: Verify the addClassIndicator(Class childClass, Object
typeValue) on the inheritance policy.

[.msg]#ECLIPSELINK-00109: This descriptor should not have a write lock
field defined because it is a child descriptor. It inherits its parent
descriptor’’s write lock field.# *Cause*: The child descriptor has a
write-lock field defined. This is unnecessary, because it inherits any
required locking from the parent descriptor.

*Action*: Check your child descriptor, and remove the field.

[.msg]#ECLIPSELINK-00110: Descriptor is missing for class [\{0}].#
*Cause*: The descriptor for the reference class className is missing
from the mapping.

*Action*: Verify the session to see if the descriptor for the reference
class was added.

[.msg]#ECLIPSELINK-00111: Multiple table primary key field names must be
fully qualified.# *Cause*: Multiple table primary key field names are
not fully qualified. These field names are given on the descriptor if it
has more than one table.

*Action*: Specify the field names with the table name.

[.msg]#ECLIPSELINK-00112: Only one table can be added by using
setTableName(String). Use addTableName(String) to add multiple tables to
a descriptor.# *Cause*: Attempt to enter more than one table through
this method.

*Action*: Use the method addTableName(String tableName) to add multiple
tables to the descriptor.

[.msg]#ECLIPSELINK-00113: The constructor was inaccessible.# *Cause*:
The constructor is inaccessible. Java is throwing this exception while
invoking a default constructor to create new instances of the domain
object.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00114: Problem in creating new instance using
creation method [\{0}]. The creation method is not accessible.# *Cause*:
The new instance methodName creation method is inaccessible. Java is
throwing an exception while calling a method to a build new instance of
the domain object. This method is given by the user to override the
default behavior of creating new instances through a class constructor.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-00115: No conversion value provided for the attribute
[\{0}].# *Cause*: The field conversion value for the attribute value
attributeValue was not given in the object type mapping.

*Action*: Verify the attribute value, and provide a corresponding field
value in the mapping.

[.msg]#ECLIPSELINK-00116: No conversion value provided for the value
[\{0}] in field [\{1}].# *Cause*: The attribute conversion value for the
fieldValue was not given in the object type mapping.

*Action*: Verify the field value, and provide a corresponding attribute
value in the mapping.

[.msg]#ECLIPSELINK-00118: The object [\{0}] must not have read-only
mappings to its write lock fields.# *Cause*: The domain object className
cannot have a read-only mapping for the write-lock fields when the
version value is stored in the object.

*Action*: Verify the mappings on the write-lock fields.

[.msg]#ECLIPSELINK-00119: The object’’s [\{0}] mappings to its write
lock fields must be read-only.# *Cause*: The domain object className
does not have a read-only mapping for the write-lock fields when the
version value is stored in the cache.

*Action*: Verify the mappings on write-lock fields.

[.msg]#ECLIPSELINK-00120: The query key [\{0}] is defined in the parent
descriptor [\{1}], but not in the child descriptor [\{2}].# *Cause*: The
query key queryKeyName is defined in the parent descriptor, but not in
the child descriptor. The descriptor has not defined the abstract query
key.

*Action*: Define any class that implements the interface descriptor by
the abstract query key in the interface descriptor.

[.msg]#ECLIPSELINK-00122: setExistenceCheck() with argument [\{0}] is
not understood.# *Cause*: The interface descriptor parent does not have
at least one abstract query key defined. The string given to the method
setExistenceChecking(String token) is not understood.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-00125: The mapping for the attribute [\{0}] uses
indirection, and so must be initialized to a new ValueHolder. Currently
the value is: [\{1}].# *Cause*: The mapping for the attribute
getAttributeName() uses indirection and must be initialized to a new
value holder.

*Action*: Ensure that the mapping uses indirection and that the
attribute is initialized to a new value holder.

[.msg]#ECLIPSELINK-00126: No subclass matches this class [\{0}] for this
Aggregate mapping with inheritance.# *Cause*: No subclass matches this
class theClass when inheritance is in aggregate relationship mapping.

*Action*: Verify the subclass and the relationship mapping.

[.msg]#ECLIPSELINK-00127: The get method for the attribute [\{0}] does
not return a ValueHolderInterface, but the mapping uses indirection.#
*Cause*: The return type of the method used to get the attribute
getAttributeName() of a mapping is not declared as type
ValueHolderInterface, but the mapping is using indirection.

*Action*: Verify that the method used to get the attribute named
getAttributeName() of DatabaseMapping returns a value holder, or change
the mapping so it does not use indirection.

[.msg]#ECLIPSELINK-00128: The get method for the attribute [\{0}]
returns a ValueHolderInterface, but the mapping does not use
indirection.# *Cause*: The return type of the method used to get the
attribute getAttributeName() of DatabaseMapping is declared as type
ValueHolderInterface, but the mapping is not using indirection.

*Action*: Ensure that the mapping is using indirection, or change the
return type from value holder.

[.msg]#ECLIPSELINK-00129: The set method for the attribute [\{0}] does
not take a ValueHolderInterface as its parameter, but the mapping uses
indirection.# *Cause*: The return type of the method used to set the
attribute getAttributeName() of DatabaseMapping is not declared as type
ValueHolderInterface, but the mapping is using indirection.

*Action*: Ensure that the set method parameter is declared as a
valueholder, or change the mapping so it does not use indirection.

[.msg]#ECLIPSELINK-00130: The set method for the attribute [\{0}] takes
a ValueHolderInterface as its parameter, but the mapping does not use
indirection.# *Cause*: The return type of the method used to set the
attribute getAttributeName() of DatabaseMapping is declared as type
ValueHolderInterface, but the mapping is not using indirection.

*Action*: Ensure that the mapping is changed to use indirection, or that
the method parameter is not declared as a value holder.

[.msg]#ECLIPSELINK-00131: The get method for the attribute [\{0}] should
return a Vector (or a type that implements Map or Collection, if using
Java 2).# *Cause*: The return type of the method used to get the
attribute getAttributeName() of DatabaseMapping is not declared as type
Vector (or a type that implements the Map or Collection interface if
using Java 2).

*Action*: Declare the return type of the method used to get the
attribute getAttributeName() of DatabaseMapping as type Vector (or a
type that implements the map or collection interface if using Java 2).

[.msg]#ECLIPSELINK-00133: The set method for the attribute [\{0}] should
take a Vector as its parameter (or a type that implements Map or
Collection, if using Java 2).# *Cause*: The parameter type of the method
used to set the attribute getAttributeName() of DatabaseMapping is not
declared as type Vector (or a type that implements the map or collection
interface, if using Java 2).

*Action*: Declare the parameter type of the method used to set the
attribute getAttributeName() of DatabaseMapping as type Vector (or a
type that implements the Map or Collection interface, if using Java 2).

[.msg]#ECLIPSELINK-00135: The multiple table foreign key relationship
refers to an unknown table [\{0}].# *Cause*: The table in the multiple
table foreign key relationship refers to an unknown table.

*Action*: Verify the table name.

[.msg]#ECLIPSELINK-00138: The attribute [\{0}] is not declared as a
superclass of [\{1}], but the mapping uses transparent indirection.#
*Cause*: The attribute getAttributeName() of DatabaseMapping is not
declared as a supertype of validTypeName, but the mapping is using
transparent indirection.

*Action*: Verify the attribute’s type and the mapping setup.

[.msg]#ECLIPSELINK-00139: The get method for the attribute [\{0}] does
not return a superclass of [\{1}], but the mapping uses transparent
indirection.# *Cause*: The return type of the method used to get the
attribute getAttributeName() of DatabaseMapping is not declared as a
super-type of validTypeName, but the mapping is using transparent
indirection.

*Action*: Verify the attribute’s type and the mapping setup.

[.msg]#ECLIPSELINK-00140: The set method for the attribute [\{0}] does
not take a superclass of [\{1}] as its parameter, but the mapping uses
transparent indirection.# *Cause*: The parameter type of the method used
to set the attribute getAttributeName() of DatabaseMapping is not
declared as a supertype of validTypeName, but the mapping is using
transparent indirection.

*Action*: Verify the attribute’s type and the mapping setup.

[.msg]#ECLIPSELINK-00141: The field [\{0}] is not present in the table
[\{1}] in the database.# *Cause*: The field fieldname is not present in
the table tableName in the database.

*Action*: Verify the field name for the attribute.

[.msg]#ECLIPSELINK-00142: The table [\{0}] is not present in the
database.# *Cause*: The table whose name is provided by the Descriptor
method getTableName is not present in the database.

*Action*: Verify the table name for the descriptor.

[.msg]#ECLIPSELINK-00143: The multiple table insert order Vector
specified, [\{0}], has more or fewer tables than are specified in the
descriptor. \{2}All of the tables [\{1}] must be included in the insert
order Vector.# *Cause*: The multiple table insert order vector specified
the Descriptor method getMultipleTableInsertOrder has fewer or more
tables than are specified in the Descriptor method getTables. All the
tables must be included in the insert order vector.

*Action*: Ensure that all table names for the descriptor are present and
that there are no extra tables.

[.msg]#ECLIPSELINK-00144: Transparent indirection can only be used with
CollectionMappings.# *Cause*: Transparent indirection is being used with
a mapping other than a CollectionMapping.

*Action*: Verify the mapping. It must be a collection mapping.

[.msg]#ECLIPSELINK-00145: The indirect container class [\{0}] must
implement the constructor [\{1}] with parameter (ValueHolderInterface).#
*Cause*: The indirect container class does not implement the
constructor.

*Action*: Implement the constructor for the container.

[.msg]#ECLIPSELINK-00146: The indirect container class [\{0}] could not
be instantiated using the constructor \{1}(ValueHolderInterface).#
*Cause*: EclipseLink is unable to instantiate the indirect container
class using the constructor.

*Action*: Validate the constructor for the indirect container class.

[.msg]#ECLIPSELINK-00147: The container policy [\{0}] should only be
used in JDK 1.1.x. It was instantiated for [\{1}].# *Cause*: You have
used a container policy with an incompatible version of the JDK. This
container policy must only be used with JDK 1.3.1 or later.

*Action*: Validate the container policy being used.

[.msg]#ECLIPSELINK-00148: The container policy [\{0}] is not compatible
with transparent indirection.# *Cause*: The container policy is
incompatible with transparent indirection.

*Action*: Change the container policy to be compatible with transparent
indirection, or do not use transparent indirection.

[.msg]#ECLIPSELINK-00149: NoIndirectionPolicy objects should not receive
this message.# *Cause*: NoIndirectionPolicy object calls this method.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-00150: The mapping for the attribute [\{0}] uses
transparent indirection so the attribute [\{0}] must be initialized to
an appropriate container. Currently the value is [\{1}]. \{2} - Must be
instance of an implementor of Collection or Map.# *Cause*: The mapping
for the attribute getAttributeName() of DatabaseMapping uses transparent
indirection and must be initialized to an appropriate container.

*Action*: Initialize the mapping to an appropriate container.

[.msg]#ECLIPSELINK-00151: The operation [\{0}] is invalid for this
mapping.# *Cause*: An invalid mapping operation has been used.

*Action*: See the documentation for valid mapping operations.

[.msg]#ECLIPSELINK-00152: The operation [\{1}] is invalid for this
indirection policy [\{0}].# *Cause*: An invalid indirection policy
operation has been used.

*Action*: See the documentation for valid indirection policy operations.

[.msg]#ECLIPSELINK-00153: The reference descriptor for [\{0}] should be
set to be an Aggregate Collection descriptor.# *Cause*: The reference
descriptor for className is not set to an aggregate collection
descriptor.

*Action*: Set the reference descriptor to an aggregate collection
descriptor.

[.msg]#ECLIPSELINK-00154: The indirection container class [\{0}] does
not implement IndirectContainer.# *Cause*: An invalid indirection
container class has been used.

*Action*: Verify the container class.

[.msg]#ECLIPSELINK-00155: This mapping does not include a foreign key
field linked to the primary key field [\{0}].# *Cause*: The mapping does
not include a foreign key field linked to the primary key field.

*Action*: Link the foreign key to the appropriate primary key.

[.msg]#ECLIPSELINK-00156: The structure name is not set for this
mapping.# *Cause*: The structure name is not set.

*Action*: Set the structure name appropriately.

[.msg]#ECLIPSELINK-00157: Normal descriptors do not support
non-relational extensions.# *Cause*: Relational descriptors do not
support nonrelational extensions.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-00158: This descriptor’’s parent class has been set
to itself.# *Cause*: The descriptor’s parent class has been set to
itself.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-00159: Proxy indirection is available only in JDK
1.3-compliant or higher virtual machines.# *Cause*: An attempt to use
proxy indirection has been made, but JDK 1.3.1 or later is not being
used.

*Action*: Use JDK 1.3.1 or later.

[.msg]#ECLIPSELINK-00160: The attribute [\{0}] of class [\{1}] is typed
as [\{2}], which was not specified in the list of interfaces given to
the useProxyIndirection() method. \{4}Valid interfaces are: [\{3}].#
*Cause*: The attribute was not specified in the list of interfaces given
to use proxy indirection.

*Action*: Verify the attribute.

[.msg]#ECLIPSELINK-00161: The method [\{0}] in class [\{1}] returns a
value of type [\{2}], which was not specified in the list of interfaces
given to the useProxyIndirection() method. \{4}Valid interfaces are:
[\{3}].# *Cause*: The return type for the indirection policy is invalid
for the indirection policy.

*Action*: Ensure that the parameter type of the getter method is correct
for the indirection policy.

[.msg]#ECLIPSELINK-00162: The method [\{0}] in class [\{1}] takes a
parameter of type [\{2}], which was not specified in the list of
interfaces given to the useProxyIndirection() method.\{4}Valid
interfaces are: [\{3}].# *Cause*: The parameter for the setter method is
incorrect for the indirection type.

*Action*: Ensure that the parameter type of the setter method is correct
for the indirection policy.

[.msg]#ECLIPSELINK-00163: This mapping’’s attribute class does not match
the collection class. [\{1}] cannot be assigned to [\{0}].# *Cause*: The
container policy is invalid for the collection type.

*Action*: Ensure that the container policy is correct for the collection
type.

[.msg]#ECLIPSELINK-00164: The amendment method [\{1}], in amendment
class [\{0}], is invalid, not public, or cannot be found. \{2}Descriptor
amendment methods must be declared "`public static void`" with
(ClassDescriptor) as the single parameter.# *Cause*: The amendment
method that is provided is invalid, not public, or cannot be found.

*Action*: Ensure that the amendment method is public, static, returns
void, and has a single argument: Descriptor.

[.msg]#ECLIPSELINK-00165: This descriptor’’s amendment method [\{1}] in
amendment class [\{0}] triggered an exception.# *Cause*: The specified
amendment method threw an exception.

*Action*: Examine the returned exception for further information.

[.msg]#ECLIPSELINK-00166: There is no mapping for the attribute [\{0}].#
*Cause*: There is no mapping for the attribute.

*Action*: Validate the mapping and attribute.

[.msg]#ECLIPSELINK-00167: A valid constructor was not found for the
indirection container class [\{0}].# *Cause*: A valid constructor was
not found for the indirection container class.

*Action*: Add a default constructor or a constructor with a
ValueHolderInterface in the container class.

[.msg]#ECLIPSELINK-00168: Problem in creating new instance using the
default constructor. The default constructor triggered an exception.#
*Cause*: The constructor is missing.

*Action*: Create the required constructor.

[.msg]#ECLIPSELINK-00169: Problem in creating new instance of factory
using the default constructor. The default constructor triggered an
exception.# *Cause*: The constructor is missing.

*Action*: Create the required constructor.

[.msg]#ECLIPSELINK-00170: Problem (illegal access) in creating new
instance of factory using the default constructor.# *Cause*: Permissions
do not allow access to the constructor.

*Action*: Adjust the Java security permissions to permit access to the
constructor.

[.msg]#ECLIPSELINK-00171: The factory class does not define a public
default constructor, or the constructor raised an exception.# *Cause*:
An instantiation failed inside the associated constructor.

*Action*: Determine which objects are being instantiated, and verify
that all are instantiated properly.

[.msg]#ECLIPSELINK-00172: Factory constructor not found.# *Cause*: A
method call from inside the constructor is invalid because this method
does not exist.

*Action*: Ensure that the factory has a default constructor for the
called method.

[.msg]#ECLIPSELINK-00173: The factory constructor was inaccessible.#
*Cause*: A method on a null object was called from inside a constructor.
The factory constructor was inaccessible.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-00174: Problem in creating factory. The creation
method [\{0}] is not accessible.# *Cause*: A method was called on an
object from inside a factory instantiation, and Java has determined this
method to be invalid.

*Action*: Determine why the method is invalid, and replace the method
with a valid one.

[.msg]#ECLIPSELINK-00175: Problem creating factory using creation method
[\{0}]. The creation method triggered an exception.# *Cause*: A problem
was encountered creating factory using creation method. The creation
method triggered an exception.

*Action*: Examine the exception and take the corresponding action.

[.msg]#ECLIPSELINK-00176: Problem in creating factory using creation
method [\{0}]. The creation method is not accessible.# *Cause*: A method
called to instantiate a factory threw a NullPointerException. The
creation method is not accessible.

*Action*: Do not use that method to instantiate a factory.

[.msg]#ECLIPSELINK-00177: Mapping is missing for the attribute: [\{0}].#
*Cause*: Mapping is missing for the attribute attributeName.

*Action*: The attribute must be mapped.

[.msg]#ECLIPSELINK-00178: Cannot find mapping for attribute [\{0}] in
entity bean [\{1}]. The attribute must mapped.# *Cause*: Cannot find
mapping for an attribute attributeName in an entity bean beanName.

*Action*: Map the attribute.

[.msg]#ECLIPSELINK-00179: The attribute, [\{0}] uses Bidirectional
Relationship Maintenance, but has ContainerPolicy, [\{1}] which does not
support it. The attribute should be mapped with a different collection
type.# *Cause*: The attribute uses bidirectional relationship
maintenance, but has ContainerPolicy, which does not support it.

*Action*: The attribute must be mapped with a different collection type.

[.msg]#ECLIPSELINK-00181: The AttributeTransformer class, [\{0}] cannot
be found.# *Cause*: The AttributeTransformer class cannot be found.

*Action*: Ensure that the AttributeTransformer class exists and is on
the classpath.

[.msg]#ECLIPSELINK-00182: The FieldTransformer class, [\{0}] cannot be
found.# *Cause*: The FieldTransformer class cannot be found.

*Action*: Ensure that the FieldTransformer class exists and is on the
classpath.

[.msg]#ECLIPSELINK-00183: The class, [\{0}] cannot be used as an
AttributeTransformer.# *Cause*: Invalid use of a class className as an
AttributeTransformer.

*Action*: Examine the internal exception stack trace and make the
appropriate correction.

[.msg]#ECLIPSELINK-00184: The class, [\{0}] cannot be used as a
FieldTransformer.# *Cause*: Invalid use of a class className as a
FieldTransformer.

*Action*: Do not use the class as a FieldTransformer.

[.msg]#ECLIPSELINK-00185: ReturningPolicy contains field, [\{0}] with
two different types: [\{1}] and [\{2}].# *Cause*: ReturningPolicy
contains field with two different types.

*Action*: The field was added to ReturningPolicy twice with different
types. The field must be added to ReturningPolicy once. You must remove
excessive addFieldForInsert and/or addInsertField calls.

[.msg]#ECLIPSELINK-00186: ReturningPolicy contains field, [\{0}] added
twice: using addInsertField and addInsertFieldReturnOnly.# *Cause*:
ReturningPolicy contains field that has been added twice using
addInsertField and addInsertFieldReturnOnly.

*Action*: A field must be added to ReturningPolicy only once. You must
remove excessive addField calls.

[.msg]#ECLIPSELINK-00187: ReturningPolicy contains field, [\{0}] with
type [\{1}], but the same field in descriptor has type [\{2}].# *Cause*:
ReturningPolicy contains field with type Type, but the same field in
descriptor has type differentType.

*Action*: Specify field type in addField method only in the event that
it cannot be obtained from the descriptor.

[.msg]#ECLIPSELINK-00188: ReturningPolicy contains unmapped field,
[\{0}] which requires type.# *Cause*: ReturningPolicy contains unmapped
field fieldName that requires type.

*Action*: You must specify field type in the addField method.

[.msg]#ECLIPSELINK-00189: ReturningPolicy contains mapped field, [\{0}]
which requires type.# *Cause*: ReturningPolicy contains mapped field
fieldName that requires type.

*Action*: You must specify field type in the addField method.

[.msg]#ECLIPSELINK-00190: ReturningPolicy contains field, [\{0}] mapped
with [\{1}] mapping which is not supported.# *Cause*: ReturningPolicy
contains a field that is mapped with unsupported mapping.

*Action*: You cannot use ReturningPolicy with this field. Do not add it
to ReturningPolicy.

[.msg]#ECLIPSELINK-00191: ReturningPolicy contains field, [\{0}] which
is not supported: it is either sequence field, or class type indicator,
or used for locking.# *Cause*: ReturningPolicy contains a field
fieldName that is not supported. Field is either sequence field, class
type indicator, or used for locking.

*Action*: You cannot use ReturningPolicy with this field. Do not add it
to ReturningPolicy.

[.msg]#ECLIPSELINK-00192: ReturningPolicy contains field, [\{0}] but
custom [\{1}] doesn’t output it.# *Cause*: ReturningPolicy contains a
field fieldName, but custom query queryName does not output it.

*Action*: Update the custom query so that it outputs a value for this
field.

[.msg]#ECLIPSELINK-00193: There is no custom [\{0}] set, but
ReturningPolicy contains field(s) to be returned and [\{1}] doesn’t
support generating call with returning.# *Cause*: There is no custom
query set, but ReturningPolicy contains one or more fields to be
returned and doesn’t support generating call with return.

*Action*: Specify a custom InsertObjectQuery or UpdateObjectQuery
through DescriptorQueryManager setInsertQuery, setInsertCall,
setUpdateQuery, or setUpdateCall methods that outputs values for fields
added to ReturningPolicy.

[.msg]#ECLIPSELINK-00194: The class extraction method [\{0}], must be a
static method on the descriptor’s class.# *Cause*: The class extraction
method must be a static method on the descriptor’s class.

*Action*: Make the class extraction method a static method on the
descriptor’s class.

[.msg]#ECLIPSELINK-00195: The shared class \{1} must not reference the
isolated class \{0}.# *Cause*: The shared class must not reference the
isolated class.

*Action*: Ensure that the shared class does not reference the isolated
class.

[.msg]#ECLIPSELINK-00196: UpdateAllFields has not been set or has been
set to false. When using CMPPolicy.setForceUpdate(true) you must also
call CMPPolicy.setUpdateAllFields(true)# *Cause*: updateAllFields flag
has not been set or has been set to false. When using
setForceUpdate(true) method of CMPPolicy you must also call
setUpdateAllFields(true) method of CMPPolicy.

*Action*: Ensure that updateAllFields is set to true if forceUpdate is
true.

[.msg]#ECLIPSELINK-00197: The mapping [\{0}] is not the appropriate type
for this descriptor# *Cause*: A mapping of an inappropriate type has
been set for this descriptor.

*Action*: The mapping type has to map the descriptor type, e.g.
relational mapping for relational descriptor, EIS mapping for EIS
descriptor, and XML mapping for XML descriptor.

[.msg]#ECLIPSELINK-00198: In order to use ObjectChangeTrackingPolicy or
AttributeChangeTrackingPolicy, \{0} has to implement ChangeTracker
interface.# *Cause*: The object does not implement the ChangeTracker
interface.

*Action*: Ensure that the object implements ChangeTrackerInterface in
order to use ObjectChangeTrackingPolicy or
AttributeChangeTrackingPolicy.

[.msg]#ECLIPSELINK-00199: In order to use Fetch Group, the domain class
(\{0}) has to implement FetchGroupTracker interface.# *Cause*: The
domain class does not implement the FetchGroupTracker interface.

*Action*: Ensure that the domain class implements the FetchGroupTracker
interface in order to use the fetch group.

[.msg]#ECLIPSELINK-00200: Attempt to register an object with dead
indirection as a new object. Possibly the object was deleted or removed
from the cache during a merge of a serialized clone. This is a
concurrency violation, consider a locking strategy.# *Cause*: Attempt to
register an object with dead indirection as a new object. Possibly, the
object was deleted or removed from the cache during a merge of a
serialized clone or did not exist in the cache at the time of the merge.
This is a concurrency violation.

*Action*: Ensure that the object exists in the cache before attempting
to merge a deserialized version into the cache. Consider a locking
strategy. For more information, see "`Merging Changes in Working Copy
Clones`" on page 112-12 and "`Indirection, Serialization, and
Detachment`" on page 17-11.

[.msg]#ECLIPSELINK-00201: An object was attempted to be built in the
session cache, but the descriptor is marked as isolated in the unit of
work, so should never be accessed outside of a unit of work.# *Cause*:
Attempt to built and object in the session cache, but the descriptor is
marked as isolated in the unit of work.

*Action*: Ensure that the descriptor is never accessed outside of a unit
of work.

== Concurrency Exceptions (2001 – 2009)

`+ConcurrencyException+` is a development exception that is raised when
a Java concurrency violation occurs. Only when a running thread is
interrupted, causing the JVM to throw an `+InterruptedException+`, is an
internal exception information displayed with the error message, as this
exampleshows.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+` `+INTERNAL EXCEPTION: Message+`

[#Example A-2]## *_Concurrency Exception_*

`+EXCEPTION [ECLIPSELINK – 2004]: org.eclipse.persistence.exceptions.ConcurrencyException+`
`+EXCEPTION DESCRIPTION: Signal attempted before wait on concurrency manager. +`
`+This usually means that an attempt was made to commit or roll back a transaction before being started, or rolled back twice.+`

[.msg]#ECLIPSELINK-02001: Wait was interrupted. \{0}Message: [\{1}]#
*Cause*: In a multi threaded environment, one of the waiting threads was
interrupted.

*Action*: Such exceptions are application-dependent.

[.msg]#ECLIPSELINK-02002: Wait failure on ServerSession.# *Cause*: A
request for a connection from the connection pool has been forced to
wait, and that wait has been interrupted.

*Action*: Such exceptions are application-dependent.

[.msg]#ECLIPSELINK-02003: Wait failure on ClientSession.# *Cause*: A
request for a connection from the connection pool has been forced to
wait, and that wait has been interrupted.

*Action*: Such exceptions are application-dependent.

[.msg]#ECLIPSELINK-02004: A signal was attempted before wait() on
ConcurrencyManager. This normally means that an attempt was made to
\{0}commit or rollback a transaction before it was started, or to
rollback a transaction twice.# *Cause*: A signal was attempted before a
wait on concurrency manager. This usually means that an attempt was made
to commit or roll back a transaction before it was started, or to
rollback a transaction twice.

*Action*: Verify transactions in the application.

[.msg]#ECLIPSELINK-02005: Wait failure on Sequencing Connection Handler
for DatabaseSession.# *Cause*: An InterruptedException was raised while
DatabaseSession sequencing waited for a separate connection to become
available.

*Action*: Examine concurrency issues involving object creation with your
DatabaseSession.

[.msg]#ECLIPSELINK-02006: Attempt to acquire sequencing values through a
single Connection(\{0}) simultaneously in multiple threads# *Cause*:
Several threads attempted to concurrently obtain sequence objects from
the same DatabaseSession or ClientSession.

*Action*: Avoid concurrent writing through the same DatabaseSession or
ClientSession.

[.msg]#ECLIPSELINK-02007: Max number of attempts to lock object: \{0}
exceded. Failed to clone the object.# *Cause*: Maximum number of
attempts to lock object was exceed resulting in a failure to clone the
object.

*Action*: Ensure that the number of attempts is within the limit.

[.msg]#ECLIPSELINK-02008: Max number of attempts to lock object: \{0}
exceded. Failed to merge the transaction.# *Cause*: Maximum number of
attempts to lock object was exceed resulting in a failure to merge the
transaction.

*Action*: Ensure that the number of attempts is within the limit.

[.msg]#ECLIPSELINK-02009: Max number of attempts to lock object exceded.
Failed to build the object. Thread: \{0} has a lock on the object but
thread: \{1} is building the object# *Cause*: Maximum number of attempts
to lock object was exceed resulting in a failure to build the object:
thread threadNumber has a lock on the object, but thread
anotherThreadNumber is building the object

*Action*: Ensure that the number of attempts is within the limit.

== Conversion Exceptions (3001– 3008)

`+ConversionException+` is a development exception that is raised when a
conversion error occurs by an incompatible type conversion. The message
that is returned indicates which type cast caused the exception.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+` `+INTERNAL EXCEPTION: Message+`

[#Example A-3]##*_Conversion Exception_*

`+EXCEPTION [ECLIPSELINK – 3006]: org.eclipse.persistence.exceptions.ConversionException+`
`+EXCEPTION DESCRIPTION: object must be of even length to be converted to a ByteArray+`

[.msg]#ECLIPSELINK-03001: The object [\{0}], of class [\{1}], could not
be converted to [\{2}].# *Cause*: Attempt to convert an object object of
class ObjectClass to JavaClass. The object cannot be converted to a
given type.

*Action*: Ensure that the object being converted is of the right type.

[.msg]#ECLIPSELINK-03002: The object [\{0}], of class [\{1}], from
mapping [\{2}] with descriptor [\{3}], could not be converted to
[\{4}].# *Cause*: Attempt to convert an object object of class
ObjectClass from mapping mappingType to JavaClass. The object cannot be
converted to a given type.

*Action*: Ensure that the object being converted is of the right type.

[.msg]#ECLIPSELINK-03003: Incorrect date format: [\{0}] (expected
[YYYY-MM-DD])# *Cause*: The date in dateString is in an incorrect
format. The expected format is YYYY-MM-DD.

*Action*: Verify the date format.

[.msg]#ECLIPSELINK-03004: Incorrect time format: [\{0}] (expected
[HH:MM:SS])# *Cause*: The time in timeString is in an incorrect format.
The expected format is HH:MM:SS.

*Action*: Verify the time format.

[.msg]#ECLIPSELINK-03005: Incorrect timestamp format: [\{0}] (expected
[YYYY-MM-DD HH:MM:SS.NNNNNNNNN])# *Cause*: The timestamp timestampString
is in an incorrect format. The expected format is YYYY-MM-DD
HH:MM:SS.NNNNNNNNN.

*Action*: Verify the timestamp format.

[.msg]#ECLIPSELINK-03006: [\{0}] must be of even length to be converted
to a byte array.# *Cause*: Attempt to convert String object of uneven
length to a ByteArray. This object cannot be converted to a ByteArray.

*Action*: Verify the object being converted.

[.msg]#ECLIPSELINK-03007: The object [\{0}], of class [\{1}], could not
be converted to [\{2}]. Please ensure that the class [\{0}] is on the
CLASSPATH. You may need to use alternate API passing in the appropriate
class loader as required, or setting it on the default
ConversionManager# *Cause*: Attempt to convert an object object of class
ObjectClass to JavaClass. The class JavaClass is not on the classpath.

*Action*: Ensure that the class JavaClass is on the classpath.

[.msg]#ECLIPSELINK-03008: Incorrect date-time format: [\{0}] (expected
[YYYY-MM-DD’T’HH:MM:SS])# *Cause*: Incorrect date-time format object.
The expected format is YYYY-MM-DD’T’HH:MM:SS.

*Action*: Ensure that the date-time object is in the expected format of
YYYY-MM-DD’T’HH:MM:SS.

== Database Exceptions (4003 – 4018)

`+DatabaseException+` is a run-time exception that is raised when data
read from the database, or the data that is to be written to the
database, is incorrect. The exception may also act as a wrapper for
`+SQLException+`. If this is the case, the message contains a reference
to the error code and error message, as shown in this example

This exception can occur on any database operation. If an execution of a
SQL script is involved in a database operation causing
`+DatabaseException+`, the exception’s message, accessible through the
`+getMessage+` method, contains the SQL that caused this exception.

This exception includes internal exception and error code information
when the exception is wrapping a `+SQLException+`.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+` `+INTERNAL EXCEPTION: Message+`
`+ERROR CODE: Error code+`

[#Example A-4]##*_Database Exception_*

`+EXCEPTION [ECLIPSELINK – 4002]: org.eclipse.persistence.exceptions.DatabaseException+`
`+EXCEPTION DESCRIPTION: java.sql.SQLException: [INTERSOLV][ODBC dBase driver] Incompatible datatypes in expression: >+`

`+INTERNAL EXCEPTION: java.sql.SQLException: [INTERSOLV][ODBC dBase driver] Incompatible datatypes in expression: >+`
`+ERROR CODE: 3924+`

[.msg]#ECLIPSELINK-04003: Configuration error. Class [\{0}] not found.#
*Cause*: The driver class name was not found.

*Action*: Verify the class name given in JDBCLogin.

[.msg]#ECLIPSELINK-04005: DatabaseAccessor not connected.# *Cause*: The
session is not connected to the database while attempting to read or
write on the database.

*Action*: An application may have to log in again because the connection
to the database might have been lost.

[.msg]#ECLIPSELINK-04006: Error reading BLOB data from stream in
getObject().# *Cause*: An error occurred reading BLOB data from the
database. There are two possibilities for this exception: either the
BLOB data was not read properly from the result set or EclipseLink
cannot process the BLOB data using ByteArrayOutputStream.

*Action*: Verify whether the underlying driver supports BLOBs properly.
If it does, then report this problem to Oracle Support Services.

[.msg]#ECLIPSELINK-04007: Could not convert object type due to an
internal error. \{0}java.sql.TYPES: [\{1}]# *Cause*: Attempt to convert
an object type on internal error.java.sql.TYPES = type. The object from
the result set cannot be converted to the type that was returned from
the metadata information.

*Action*: Verify whether the underlying driver supports the conversion
type properly. If it does, then report this problem to Oracle Support
Services.

[.msg]#ECLIPSELINK-04008: You cannot logout while a transaction is in
progress.# *Cause*: Attempt to log out while the transaction is still in
progress. You cannot log out while a transaction is in progress.

*Action*: Wait until the transaction is finished.

[.msg]#ECLIPSELINK-04009: The sequence table information is not
complete.# *Cause*: The sequence information given to EclipseLink is not
sufficiently complete to get the set of sequence numbers from the
database. This usually happens on native sequencing on an Oracle
database.

*Action*: Verify the data provided, especially the sequence name
provided in EclipseLink.

[.msg]#ECLIPSELINK-04011: Error preallocating sequence numbers. The
sequence table information is not complete.# *Cause*: An error occurred
preallocating sequence numbers on the database; the sequence table
information is not complete.

*Action*: Ensure the sequence table was properly created on the
database.

[.msg]#ECLIPSELINK-04015: Synchronized UnitOfWork does not support the
commitAndResume() operation.# *Cause*: A synchronized UnitOfWork does
not support the commitAndResume operation. When the EclipseLink session
is configured with an ExternalTransactionController, any unit of work
requested by a client must operate within the context of a JTS external
global transaction (see ). The JTS specification does not support the
concept of check pointing a transaction-that is, committing the work
performed and then continuing to work within the same transaction
context. JTS does not support nested transactions, either. As a result,
if a client code invokes commitAndResume on a synchronized unit of work,
this error is reported.

*Action*: None required.

[.msg]#ECLIPSELINK-04016: Configuration error. Could not instantiate
driver [\{0}].# *Cause*: A configuration error occurred when EclipseLink
attempted to instantiate the given driver class. EclipseLink cannot
instantiate the driver.

*Action*: Check the driver.

[.msg]#ECLIPSELINK-04017: Configuration error. Could not access driver
[\{0}].# *Cause*: A configuration error occurred when EclipseLink
attempted to instantiate the given driver class. EclipseLink cannot
instantiate the driver.

*Action*: Check the driver.

[.msg]#ECLIPSELINK-04018: The TransactionManager has not been set for
the JTS driver.# *Cause*: The transaction manager has not been set for
the JTSSynchronizationListener.

*Action*: Set a transaction manager for the JTSSynchronizationListener.

== Optimistic Lock Exceptions (5001 – 5009)

`+OptimisticLockException+` is a run-time exception that is raised when
the row on the database that matches the desired object is missing or
when the value on the database does not match the registered number. It
is used in conjunction with the optimistic locking feature. This applies
only on an update or delete operation, as shown in this example.

For more information about optimistic locking, see the section on
optimistic locking in a stateless environment in
link:Introduction_to_EclipseLink_Application_Development_(ELUG)[Introduction
to EclipseLink Application Development]. These exceptions should be
handled in a try-catch block.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception Name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-5]##*_Optimistic Lock Exception_*

`+EXCEPTION [ECLIPSELINK – 5003]: org.eclipse.persistence.exceptions.OptimisticLockException+`
`+EXCEPTION DESCRIPTION: The object, object.toString() cannot be deleted because it has changed or been deleted since it was last read.+`

[.msg]#ECLIPSELINK-05001: An attempt was made to delete the object
[\{0}], but it has no version number in the identity map. \{3}It may not
have been read before the delete was attempted. \{3}Class> \{1} Primary
Key> \{2}# *Cause*: Attempt to delete the object object that does not
have a version number in the identity map. This object either was never
read or has already been deleted.

*Action*: Use SQL logging to determine the reason for the exception. The
last delete operation shows the object being deleted when the exception
was raised.

[.msg]#ECLIPSELINK-05003: The object [\{0}] cannot be deleted because it
has changed or been deleted since it was last read. \{3}Class> \{1}
Primary Key> \{2}# *Cause*: The object state has changed in the
database. The object object cannot be deleted because it has changed or
been deleted since it was last read. This usually means that the row in
the table was changed by some other application.

*Action*: Refresh the object, which updates it with the new data from
the database.

[.msg]#ECLIPSELINK-05004: An attempt was made to update the object
[\{0}], but it has no version number in the identity map. \{3}It may not
have been read before the update was attempted. \{3}Class> \{1} Primary
Key> \{2}# *Cause*: An attempt has been made to update the object object
that does not have a version number in the identity map. It may not have
been read before being updated, or it has been deleted.

*Action*: Use SQL logging to determine the reason for the exception. The
last update operation shows the object being updated when the exception
was raised.

[.msg]#ECLIPSELINK-05006: The object [\{0}] cannot be updated because it
has changed or been deleted since it was last read. \{3}Class> \{1}
Primary Key> \{2}# *Cause*: The object state has changed in the
database. The object object cannot be updated because it has changed or
been deleted since it was last read. This usually means that the row in
the table was changed by some other application.

*Action*: Refresh the object, which updates it with the new data from
the database.

[.msg]#ECLIPSELINK-05007: The object [\{0}] must have a non-read-only
mapping to the version lock field.# *Cause*: The object object does not
have a non-read-only mapping corresponding to the version lock field.
The mapping, which is needed when the lock value is stored in the domain
object rather than in a cache, was not defined for the locking field.

*Action*: Define a mapping for the field.

[.msg]#ECLIPSELINK-05008: Must map the version lock field to
java.sql.Timestamp when using Timestamp Locking# *Cause*: A write lock
value that is stored in a domain object is not an instance of
java.sql.Timestamp.

*Action*: Change the value of the attribute to be an instance of
java.sql.Timestamp.

[.msg]#ECLIPSELINK-05009: The object of class [\{1}] with primary key
[\{0}] cannot be unwrapped because it was deleted since it was last
read.# *Cause*: Attempt to unwrapped an object of class className with
primary key key-the object was deleted since it had been last read.

*Action*: Ensure the existence of the object being upwrapped.

== Query Exceptions (6001 – 6129)

`+QueryException+` is a development exception that is raised when
insufficient information has been provided to the query. If possible,
the message indicates the query that caused the exception. A query is
optional and is displayed if EclipseLink is able to determine the query
that caused this exception, as shown in this example

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+` `+QUERY:+`

[#Example A-6]##*_Query Exception_*

`+EXCEPTION [ECLIPSELINK – 6026]: org.eclipse.persistence.exceptions.QueryException+`
`+EXCEPTION DESCRIPTION: The query is not defined. When executing a +`
`+query on the session, the parameter that takes the query is null.+`

[.msg]#ECLIPSELINK-06001: Cursored SQL queries must provide an
additional query to retrieve the size of the result set.# *Cause*:
Additional size-retrieving query was not specified: cursored SQL queries
must provide an additional query to retrieve the size of the result set.
Failure to include the additional query causes this exception.

*Action*: Specify a size query.

[.msg]#ECLIPSELINK-06002: Aggregated objects cannot be
written/deleted/queried independently from their owners. \{1}Descriptor:
[\{0}]# *Cause*: An aggregated object was deleted independently of its
owner: aggregate objects cannot be written or deleted independent of
their owners. No identity is maintained on such objects.

*Action*: Do not try to delete aggregate objects directly.

[.msg]#ECLIPSELINK-06003: The number of arguments provided to the query
for execution does not match the number of arguments in the query
definition.# *Cause*: The number of arguments provided to the query for
execution does not match the number of arguments provided with the query
definition.

*Action*: Check the query and the query execution.

[.msg]#ECLIPSELINK-06004: The object [\{0}], of class [\{1}], with
identity hashcode (System.identityHashCode()) [\{2}], \{3}is not from
this UnitOfWork object space, but the parent session’’s. The object was
never registered in this UnitOfWork, \{3}but read from the parent
session and related to an object registered in the UnitOfWork. Ensure
that you are correctly\{3}registering your objects. If you are still
having problems, you can use the UnitOfWork.validateObjectSpace() method
to \{3}help debug where the error occurred. For more information, see
the manual or FAQ.# *Cause*: The object clone of class clone.getClass()
with identity hash code (System.identityHashCode())
(System.identityHashCode(clone)) is not from this unit of work space,
but from the parent session. The object was never registered in this
unit of work, but read from the parent session and related to an object
registered in the unit of work.

*Action*: Verify that you are correctly registering your objects. If you
are still having problems, use the validateObjectSpace method of the
UnitOfWork to help debug where the error occurred.

[.msg]#ECLIPSELINK-06005: The object [\{0}], of class [\{1}], with
identity hashcode (System.identityHashCode()) [\{2}], \{3}is the
original to a registered new object. The UnitOfWork clones registered
new objects, so you must ensure that an object \{3}is registered before
it is referenced by another object. If you do not want the new object to
be cloned, use the\{3}UnitOfWork.registerNewObject(Object) API. If you
are still having problems, you can use the
UnitOfWork.validateObjectSpace() \{3}method to help debug where the
error occurred. For more information, see the manual or FAQ.# *Cause*:
The object clone of class clone.getClass() with identity hash code
(System.identityHashCode()) (System.identityHashCode(clone)) is the
original to a registered new object. Because the unit of work clones new
objects that are registered, ensure that an object is registered before
it is referenced by another object. If you do not want the new object to
be cloned, use the registerNewObject(Object) method of the UnitOfWork.

*Action*: Verify that you are correctly registering your objects. If you
are still having problems, use the validateObjectSpace method of the
UnitOfWork to help debug where the error occurred.

[.msg]#ECLIPSELINK-06006: The mapping [\{0}] does not support batch
reading.# *Cause*: The mapping that does not support batch reading was
used. The optimization of batch reading all the target rows is not
supported for the mapping.

*Action*: The problem is an EclipseLink development problem, and you
should never encounter this error code unless the mapping is a new
custom mapping. Contact Oracle Support Services.

[.msg]#ECLIPSELINK-06007: Missing descriptor for [\{0}].# *Cause*: The
descriptor for the reference class is missing. The descriptor related to
the class or the object is not found in the session.

*Action*: Verify whether or not the related descriptor was added to the
session, and whether or not the query is performed on the right object
or class.

[.msg]#ECLIPSELINK-06008: Missing descriptor for [\{0}] for query named
[\{1}].# *Cause*: The descriptor DomainClassName for the query named
queryName is missing. The descriptor where named query is defined is not
added to the session.

*Action*: Verify whether or not the related descriptor was added to the
session, and whether or not the query is performed on the right class.

[.msg]#ECLIPSELINK-06013: Incorrect size query given to CursoredStream.#
*Cause*: The size query given on the queries returning cursor streams is
not correct. The execution of the size query did not return any size.

*Action*: If the cursor stream query was a custom query, then check the
size of the query that was specified, or report this problem to Oracle
Support Services.

[.msg]#ECLIPSELINK-06014: Objects cannot be written during a UnitOfWork,
they must be registered.# *Cause*: Attempt to write an object in a unit
of work using modify queries. These objects must be registered.

*Action*: Prior to modification, register objects in the unit of work,
so during commit the unit of work can perform the required changes to
the database.

[.msg]#ECLIPSELINK-06015: Invalid query key [\{0}] in expression.#
*Cause*: The query key key does not exist. Usually this happens because
of a misspelled query key.

*Action*: Check the query key that was specified in the expression and
verify that a query key was added to the descriptor.

[.msg]#ECLIPSELINK-06016: Objects or the database cannot be changed
through a ServerSession. All changes must be done through a
ClientSession’’s UnitOfWork.# *Cause*: Attempt to change an object or a
database through the server session: all changes must be performed
through a client session’s unit of work. The objects cannot be changed
on the server session by modifying queries. Objects are changed in the
client sessions that are acquired from this server session.

*Action*: Use the client session’s unit of work to change the object.

[.msg]#ECLIPSELINK-06020: No concrete class indicated for the type in
the row [\{0}].# *Cause*: No concrete class is indicated for the type in
this row. The type indicator read from the database row has no entry in
the type indicator hash table or if class extraction method was used, it
did not return any concrete class type. The exception is raised when
subclasses are being read.

*Action*: Check the class extraction method, if specified, or check the
descriptor to verify all the type indicator values were specified.

[.msg]#ECLIPSELINK-06021: Cursors are not supported for interface
descriptors, or abstract class multiple table descriptors using
expressions. Consider using custom SQL or multiple queries.# *Cause*: No
cursor support is provided for abstract class multiple table descriptors
using expressions.

*Action*: Consider using custom SQL or multiple queries.

[.msg]#ECLIPSELINK-06023: The list of fields to insert into the table
[\{0}] is empty. You must define at least one mapping for this table.#
*Cause*: There are no fields to be inserted into the table. The fields
to insert into the table table, are empty.

*Action*: Define at least one mapping for this table.

[.msg]#ECLIPSELINK-06024: Modify queries require an object to modify.#
*Cause*: An object to modify has not been specified for a modify query.

*Action*: Verify that the query contains an object before executing.

[.msg]#ECLIPSELINK-06026: Query named [\{0}] is not defined. Domain
class: [\{1}]# *Cause*: The query is not defined. When executing a query
on the session, the parameter that takes the query is null.

*Action*: Verify that the query is passed properly.

[.msg]#ECLIPSELINK-06027: Query sent to a unactivated UnitOfWork.#
*Cause*: The unit of work has been released and is now inactive.

*Action*: The unit of work, once released, cannot be reused unless the
commitAndResume method is called.

[.msg]#ECLIPSELINK-06028: An attempt to read beyond the end of stream
occurred.# *Cause*: Attempt to read from the cursor streams beyond its
limits (beyond the end of the stream).

*Action*: Ensure that the stream is checked for an end of stream
condition before attempting to retrieve more objects.

[.msg]#ECLIPSELINK-06029: A reference class must be provided.# *Cause*:
The reference class in the query is not specified: a reference class
must be provided.

*Action*: Ensure that the query is correct.

[.msg]#ECLIPSELINK-06030: Refreshing is not possible if caching is not
enabled.# *Cause*: Attempt to refresh while the caching is not set: the
read queries that skip the cache to read objects cannot be used to
refresh the objects. Refreshing is not possible without identity.

*Action*: Ensure that the query is correct.

[.msg]#ECLIPSELINK-06031: size() is only supported on expression
queries, unless a size query is given.# *Cause*: EclipseLink did not
find a size query. Size is supported only on expression queries unless a
size query is given.

*Action*: The cursor streams on a custom query should also define a size
query.

[.msg]#ECLIPSELINK-06032: The SQL statement has not been properly set.#
*Cause*: The SQL statement has not been properly set. The user should
never encounter this error code unless queries have been customized.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-06034: Invalid query item expression [\{0}].#
*Cause*: EclipseLink is unable to validate a query item expression.

*Action*: Validate the expression being used.

[.msg]#ECLIPSELINK-06041: The selection object passed to a
ReadObjectQuery was null.# *Cause*: The selection object that was passed
to a ReadObjectQuery (or refresh) was null.

*Action*: Check setSelectionObject method on read query.

[.msg]#ECLIPSELINK-06042: A session name must be specified for
non-object-level queries. See the setSessionName(String) method.#
*Cause*: Data read and data modify queries are being executed without
the session name. Only object-level queries can be directly executed by
the session broker, unless the query is named.

*Action*: Specify the session name.

[.msg]#ECLIPSELINK-06043: ReportQueries without primary keys cannot use
readObject(). \{1}ReportQueryResult: [\{0}].# *Cause*: Attempt to read
the object by a ReportQuery without a primary key: the report query
result that was returned is without primary key values. An object from
the result can be created only if primary keys were also read.

*Action*: See the documentation about retrievePrimaryKeys method on
report query.

[.msg]#ECLIPSELINK-06044: The primary key read from the row [\{0}]
during the execution of the query was detected to be null. Primary keys
must not contain null.# *Cause*: The primary key that was read from the
row databaseRow during the execution of the query was detected to be
null: primary keys must not contain null.

*Action*: Check the query and the table on the database.

[.msg]#ECLIPSELINK-06045: The subclass [\{0}], indicated in the row
while building the object, has no descriptor defined for it.# *Cause*:
The subclass has no descriptor defined for it.

*Action*: Ensure the descriptor was added to the session, or check class
extraction method.

[.msg]#ECLIPSELINK-06046: Cannot delete an object of a read-only class.
The class [\{0}] is declared as read-only in this UnitOfWork.# *Cause*:
Attempt to delete a read-only class.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-06047: Invalid operator [\{0}] in expression.#
*Cause*: The operator used in the expression is not valid.

*Action*: Check ExpressionOperator class to see a list of all the
operators that are supported.

[.msg]#ECLIPSELINK-06048: Illegal use of getField() [\{0}] in
expression.# *Cause*: Invalid use of getField method’s data in the
expression. This is an EclipseLink development exception that you should
not encounter.

*Action*: Report this problem to Oracle Support Services.

[.msg]#ECLIPSELINK-06049: Illegal use of getTable() [\{0}] in
expression.# *Cause*: Invalid use of getTable method’s data in the
expression. This is an EclipseLink development exception that you should
not encounter.

*Action*: Report this problem to Oracle Support Services.

[.msg]#ECLIPSELINK-06050: ReportQuery result size mismatch. Expecting
[\{0}], but retrieved [\{1}]# *Cause*: The number of attributes
requested does not match the attributes returned from the database in
report query. This can happen as a result of a custom query on the
report query.

*Action*: Check the custom query to ensure it is specified, or report
the problem to Oracle Support Services.

[.msg]#ECLIPSELINK-06051: Partial object queries are not allowed to
maintain the cache or be edited. You must use dontMaintainCache().#
*Cause*: Attempt to cache a partial object: partial objects are never
put in the cache. Partial object queries are not allowed to maintain the
cache or to be edited. Use the dontMaintainCache method.

*Action*: Call the dontMaintainCache method before executing the query.

[.msg]#ECLIPSELINK-06052: An outer join (getAllowingNull or
anyOfAllowingNone) is only valid for OneToOne, OneToMany, ManyToMany,
AggregateCollection and DirectCollection Mappings, and cannot be used
for the mapping [\{0}].# *Cause*: Invalid use of an outer join: an outer
join (getAllowingNull method) is valid only for one-to-one mappings and
cannot be used for the mapping.

*Action*: Do not attempt to use the getAllowingNull method for mappings
other than one-to-one.

[.msg]#ECLIPSELINK-06054: Cannot add the object [\{0}], of class [\{1}],
to container class [\{2}] using policy [\{3}].# *Cause*: EclipseLink is
unable to add an object to a container class using policy. This is
EclipseLink development exception, and you should never encounter this
problem unless a custom container policy has been written.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-06055: The method invocation of the method [\{0}] on
the object [\{1}], of class [\{2}], triggered an exception.# *Cause*:
The invocation of a method on the object anObject threw a Java
reflection exception while accessing the method.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-06056: Cannot create a clone of object [\{0}], of
class [\{1}], using [\{2}].# *Cause*: Attempt to create a clone of the
object anObject using policy. This is an EclipseLink development
exception, and you should never encounter this problem unless a custom
container policy has been written.

*Action*: Report this problem to Oracle Support Services.

[.msg]#ECLIPSELINK-06057: The method [\{0}] is not a valid method to
call on object [\{1}].# *Cause*: Invalid call of the method methodName
on object aReceiver. This is an EclipseLink development exception, and
you should never encounter this problem unless a custom container policy
has been written.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-06058: The method [\{0}] was not found in class
[\{1}].# *Cause*: The method named methodName was not found in the class
aClass. This exception is raised when looking for a clone method on the
container class. The clone is needed to create clones of the container
in unit of work.

*Action*: Define a clone method on the container class.

[.msg]#ECLIPSELINK-06059: The class [\{0}] cannot be used as the
container for the results of a query because it cannot be instantiated.#
*Cause*: Attempt to instantiate a class aClass as the container for the
results of a query-this class cannot be instantiated as a container. The
exception is a Java exception that is raised when a new interface
container policy is being created using Java reflection. EclipseLink
wraps only the Java exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-06060: Could not use object [\{0}] of type [\{1}] as
a key into [\{2}] of type [\{3}]. The key cannot be compared with the
keys currently in the Map.# *Cause*: Attempt to use the object anObject
of type ObjectClass as a key into aContainer which is of type
ContainerClass. The key cannot be compared with the keys currently in
the map. This raises a Java reflection exception while accessing the
method. EclipseLink wraps only the Java exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-06061: Cannot reflectively access the method [\{0}]
for object [\{1}], of class [\{2}].# *Cause*: Attempt to reflectively
access the method aMethod for object: anObject of type ObjectClass. This
raises a Java reflection exception while accessing the method.
EclipseLink wraps only the Java exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-06062: The method [\{0}], called reflectively on
object [\{1}], of class [\{2}], triggered an exception.# *Cause*: The
method aMethod was called reflectively on objectClass and threw an
exception. The method aMethod raises a Java reflection exception while
accessing a method. EclipseLink wraps only the Java exception.

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-06063: Invalid operation [\{0}] on cursor.# *Cause*:
Invalid operation operationName on the cursor. The operation is not
supported.

*Action*: Check the class documentation and look for the corresponding
method to use.

[.msg]#ECLIPSELINK-06064: Cannot remove the object [\{0}], of class
[\{1}], from container class [\{2}] using policy [\{3}].# *Cause*:
Attempt to remove anObject of type anObjectClass from aContainerClass
using policy. This is an EclipseLink development exception and you
should never encounter this problem unless a custom container policy has
been written.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-06065: Cannot add the object [\{0}], of class [\{1}],
to container [\{2}].# *Cause*: Attempt to add an element to the
collection container policy (cannot add object anObject of type
ObjectClass to a ContainerClass).

*Action*: Inspect the internal exception, and refer to the Java
documentation.

[.msg]#ECLIPSELINK-06066: The object [\{0}], of class [\{1}], with
identity hashcode (System.identityHashCode()) [\{2}], \{3}has been
deleted, but still has references. Deleted objects cannot be referenced
after being deleted. \{3}Ensure that you are correctly registering your
objects. If you are still having problems, you can use the
UnitOfWork.validateObjectSpace() \{3}method to help debug where the
error occurred. For more information, see the manual or FAQ.# *Cause*:
Object references remained after the deletion of the object: the object
clone of class clone.getClass with identity hash code
(System.identityHashCode()) (System.identityHashCode(clone)) has been
deleted, but it still has references.

*Action*: Ensure that you are correctly registering your objects. If you
are still having problems, use the validateObjectSpace() method of the
UnitOfWork to help identify where the error occurred.

[.msg]#ECLIPSELINK-06068: Cannot compare table reference to [\{0}] in
expression.# *Cause*: Attempt to compare table reference to data in
expression.

*Action*: Check the expression.

[.msg]#ECLIPSELINK-06069: The field [\{0}] in this expression has an
invalid table in this context.# *Cause*: Field has invalid table in this
context for field fieldName in expression.

*Action*: Check the expression.

[.msg]#ECLIPSELINK-06070: Invalid use of a query key [\{0}] representing
a "`to-many`" relationship in an expression. Use anyOf() rather than
get().# *Cause*: Invalid use of a query key representing a one-to-many
relationship in expression.

*Action*: Use the anyOf operator instead of the get operator.

[.msg]#ECLIPSELINK-06071: Invalid use of anyOf() for a query key [\{0}]
not representing a to-many relationship in an expression. Use get()
rather than anyOf().# *Cause*: Invalid use of anyOf for a query key not
representing a to-many relationship in expression.

*Action*: Use the get operator instead of the anyOf operator.

[.msg]#ECLIPSELINK-06072: Querying across a VariableOneToOneMapping is
not supported. \{2}Descriptor: [\{0}] \{2}Mapping: [\{1}]# *Cause*:
Attempt to query across a variable one-to-one mapping. This is not
supported.

*Action*: Change the expression such that the query is not performed
across a variable one-to-one mapping.

[.msg]#ECLIPSELINK-06073: Malformed expression in query. Attempting to
print an object reference into an SQL statement for query key [\{0}].#
*Cause*: Ill-formed expression in query that is attempting to print an
object reference into a SQL statement for queryKey.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-06074: This expression cannot determine if the object
conforms in memory. You must set the query to check the database.#
*Cause*: Expression cannot determine if the object conforms in memory.

*Action*: Set the query to check the database; change the query such
that it does not attempt to conform to the results of the query.

[.msg]#ECLIPSELINK-06075: Object comparisons can only use the equal() or
notEqual() operators. Other comparisons must be done through query keys
or direct attribute level comparisons. \{1}Expression: [\{0}]# *Cause*:
Invalid operator was used for the object comparison: object comparisons
can use only the equal or notEqual operators; other comparisons must be
performed through query keys or direct attribute level comparisons.

*Action*: Ensure the query uses only equal and notEqual if object
comparisons are being used.

[.msg]#ECLIPSELINK-06076: Object comparisons can only be used with
OneToOneMappings. Other mapping comparisons must be done through query
keys or direct attribute level comparisons. \{2}Mapping: [\{0}]
\{2}Expression: [\{1}]# *Cause*: Unsupported type of mapping was used
for the object comparison: object comparisons can be used only with
one-to-one mappings; other mapping comparisons must be performed through
query keys or direct attribute level comparisons.

*Action*: Use a query key instead of attempting to compare objects
across the mapping.

[.msg]#ECLIPSELINK-06077: Object comparisons cannot be used in parameter
queries. You must build the expression dynamically. \{1}Expression:
[\{0}]# *Cause*: Object comparison was parameterized: object comparisons
cannot be used in parameter queries.

*Action*: Change the query so that it does not attempt to use objects
when using parameterized queries.

[.msg]#ECLIPSELINK-06078: The class of the argument for the object
comparison is incorrect. \{3}Expression: [\{0}] \{3}Mapping: [\{1}]
\{3}Argument: [\{2}]# *Cause*: An incorrect class of the argument was
used for the object comparison.

*Action*: Ensure the class for the query is correct.

[.msg]#ECLIPSELINK-06079: Object comparison cannot be used for target
foreign key relationships. Query on the source primary key instead.
\{3}Expression: [\{0}] \{3}Mapping: [\{1}] \{3}Argument: [\{2}]#
*Cause*: Object comparison was used for target foreign key
relationships: object comparisons cannot be used for target foreign key
relationships

*Action*: Query on the source primary key.

[.msg]#ECLIPSELINK-06080: Invalid database call [\{0}]. The call must be
an instance of DatabaseCall.# *Cause*: Invalid database call: the call
must be an instance of DatabaseCall.

*Action*: Ensure the call being used is a DatabaseCall.

[.msg]#ECLIPSELINK-06081: Invalid database accessor [\{0}]. The accessor
must be an instance of DatabaseAccessor.# *Cause*: Invalid database
accessor: the accessor must be an instance of DatabaseAccessor.

*Action*: Ensure the accessor being used is a DatabaseAccessor.

[.msg]#ECLIPSELINK-06082: The method [\{0}] with argument types [\{1}]
cannot be invoked on Expression.# *Cause*: The nonexisting method
methodName with argument type argTypes was invoked on an expression.

*Action*: Ensure the method being used is a supported method.

[.msg]#ECLIPSELINK-06083: Queries using in() cannot be parameterized.
Disable either query preparation or binding.# *Cause*: The query that
was using IN was parameterized: queries using IN cannot be
parameterized.

*Action*: Disable the query prepare or binding.

[.msg]#ECLIPSELINK-06084: The redirection query was not configured
properly. The class or method name was not set.# *Cause*: The
redirection query was not configured properly: the class or method name
was not set.

*Action*: Verify the configuration for the redirection class.

[.msg]#ECLIPSELINK-06085: The redirection query’’s method is not defined
or defined with the wrong arguments. It must be declared "`public
static`" and have arguments (DatabaseQuery, Record, Session) or
(Session, Vector). \{2}Class: [\{0}] \{2}Method: [\{1}]# *Cause*: The
redirection query’s method is not defined or it is defined with the
wrong arguments. It must be public static and have the following
arguments: DatabaseQuery, DatabaseRow, or Session (the interface).

*Action*: Check the redirection query’s method.

[.msg]#ECLIPSELINK-06086: The redirection query’’s method invocation
triggered an exception.# *Cause*: The static invoke method provided to
MethodBaseQueryRedirector threw an exception when invoked.

*Action*: Check the static invoke method for problems.

[.msg]#ECLIPSELINK-06087: The example object class [\{0}] does not match
the reference object class [\{1}].# *Cause*: There is a class mismatch
between the example object and the reference class specified for this
query.

*Action*: Ensure that the example and reference classes are compatible.

[.msg]#ECLIPSELINK-06088: There are no attributes for the ReportQuery.#
*Cause*: A ReportQuery has been built with no attributes specified.

*Action*: Specify the attribute for the query.

[.msg]#ECLIPSELINK-06089: The expression has not been initialized
correctly. Only a single ExpressionBuilder should be used for a query.
\{1}For parallel expressions, the query class must be provided to the
ExpressionBuilder constructor, and the query’’s ExpressionBuilder must
\{1}always be on the left side of the expression. \{1}Expression:
[\{0}]# *Cause*: The expression has not been initialized correctly. Only
a single ExpressionBuilder should be used for a query. For parallel
expressions, the query class must be provided to the ExpressionBuilder
constructor, and the query’s ExpressionBuilder must always be on the
left side of the expression.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-06090: Cannot set ReportQuery to "`check cache
only`".# *Cause*: The checkCacheOnly method was invoked on a
ReportQuery. You cannot invoke the checkCacheOnly method on a
ReportQuery, because a ReportQuery returns data rather than objects and
the EclipseLink cache is built with objects.

*Action*: Do not use a ReportQuery in this case.

[.msg]#ECLIPSELINK-06091: The type of the constant [\{0}], used for
comparison in the expression, does not match the type of the attribute
[\{1}].# *Cause*: The type of the constant used for comparison in the
expression does not match the type of the attribute.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-06092: Uninstantiated ValueHolder detected. You must
instantiate the relevant Valueholders to perform this in-memory query.#
*Cause*: Uninstantiated value holders have been detected.

*Action*: Instantiate the value holders for the collection on which you
want to query.

[.msg]#ECLIPSELINK-06094: The parameter name [\{0}] in the query’’s
selection criteria does not match any parameter name defined in the
query.# *Cause*: An unmapped field was used in a parameterized
expression.

*Action*: Map the field or define an alternate expression that does not
rely on the unmapped field.

[.msg]#ECLIPSELINK-06095: Public clone method is required.# *Cause*: A
delegate class of an IndirectContainer implementation does not implement
Cloneable. If you implement IndirectContainer you must also implement
Cloneable. For example, see
org.eclipse.persistence.indirection.IndirectSet. The clone method must
clone the delegate. For example, the IndirectSet implementation uses
reflection to invoke the clone method because it is not included in the
common interface shared by IndirectSet and its base delegate class,
HashSet.

*Action*: Ensure that your IndirectContainer implementation or its
delegate class implements Cloneable.

[.msg]#ECLIPSELINK-06096: Clone method is inaccessible.# *Cause*: A
delegate class of an IndirectContainer implementation implements
Cloneable but the IndirectContainer implementation does not have access
to the specified clone method. That is, a
java.lang.IllegalAccessException is raised when the delegate’s clone
method is invoked.

*Action*: Ensure that both the delegate clone method and the delegate
class are public. Ensure permission is set for Java reflection in your
VM security settings. See also the invoke method of
java.lang.reflect.Method.

[.msg]#ECLIPSELINK-06097: clone method threw an exception: \{0}.#
*Cause*: A delegate class of an IndirectContainer implementation
implements Cloneable and the IndirectContainer implementation has access
to the specified clone method, but the specified clone method raises a
java.lang.reflect.InvocationTargetException when invoked.

*Action*: Verify the implementation of the delegate’s clone method.

[.msg]#ECLIPSELINK-06098: Unexpected Invocation Exception: \{0}.#
*Cause*: A proxy object method raises an unexpected exception when
invoked (that is, some exception other than InvocationTargetException
and ValidationException.)

*Action*: Review the proxy object to see where it is throwing the
exception described in the exception message. Ensure this exception is
no longer raised.

[.msg]#ECLIPSELINK-06099: Joining across inheritance class with multiple
table subclasses not supported: \{0}, \{1}# *Cause*: Joining with query
across inheritance class with multiple table subclasses. This is not
supported: joining cannot be used on relationships with inheritance
classes that have subclasses that span multiple tables as this requires
multiple separate queries. The multiple queries cannot be joined into a
single query.

*Action*: Use batch reading on the relationship instead, as this will
provide equivalent or better performance.

[.msg]#ECLIPSELINK-06100: Multiple values detected for single-object
read query.# *Cause*: Multiple values detected for single-object read
query. This is a CMP compliance option that ensures the finder methods
for a single object only return a single row.

*Action*: Set the system property toplink.cts.checkMultipleRows to
false, or ensure that the finder query only returns a single row from
the database.

[.msg]#ECLIPSELINK-06101: Executing this query could violate the
integrity of the global session cache which must contain only the latest
versions of objects. In order to execute a query that returns objects as
of a past time, try one of the following: Use a HistoricalSession
(acquireSessionAsOf), all objects read will be cached and automatically
read as of the same time. This will apply even to triggering object
relationships. Set shouldMaintainCache to false. You may make any object
expression as of a past time, provided none of its fields are
represented in the result set (i.e. used only in the where clause).#
*Cause*: Executing this query could violate the integrity of the global
session cache which must contain only the latest versions of objects.

*Action*: To execute a query that returns objects of a historical
nature, you must do one of the following:Use a HistoricalSession
(acquireSessionAsOf). All objects read will be cached and automatically
read at that time. This applies also to triggering object
relationships.Set shouldMaintainCache to false. You may make any object
expression as of a previous time, provided none of its fields are
represented in the result set (i.e. used in the where clause).

[.msg]#ECLIPSELINK-06102: At present historical queries only work with
Oracle 9R2 or later databases, as it uses Oracle’s Flashback feature.#
*Cause*: Invalid database was used: historical queries only work with
Oracle 9.2.0.4 or later databases, as it uses the Oracle database
Flashback feature.

*Action*: Ensure that historical queries are only used with an Oracle
9.2.0.4 or later database.

[.msg]#ECLIPSELINK-06103: You may not execute a WriteQuery from inside a
read-only HistoricalSession. To restore past objects, try the following:
read the same object as it is now with a UnitOfWork and commit the
UnitOfWork.# *Cause*: Invalid query was executed on a historical
session: you may not execute a WriteQuery from inside a read-only
HistoricalSession. To restore historical objects, try the following:
read the same object as it is now with a UnitOfWork and commit the
UnitOfWork.

*Action*: To restore historical objects, read the same object as it is
now with a UnitOfWork and commit the UnitOfWork.

[.msg]#ECLIPSELINK-06104: The object, \{0}, does not exist in the
cache.# *Cause*: The object does not exist in the cache.

*Action*: Ensure that the object exists in the cache.

[.msg]#ECLIPSELINK-06105: Query has to be reinitialized with a cursor
stream policy.# *Cause*: The cursor stream policy was not used on the
query instantiation.

*Action*: Reinitialize the query with a cursor stream policy.

[.msg]#ECLIPSELINK-06106: The object of type [\{0}] with primary key
[\{1}] does not exist in the cache.# *Cause*: The object with primary
key does not exist in the cache.

*Action*: Ensure that the object exists in the cache.

[.msg]#ECLIPSELINK-06107: Missing update statements on UpdateAllQuery.#
*Cause*: Missing update statements on UpdateAllQuery.

*Action*: Add update statements using the addUpdate method.

[.msg]#ECLIPSELINK-06108: Update all query does not support inheritance
with multiple tables# *Cause*: For UpdateAllQuery, inheritance was used
with multiple tables: UpdateAllQuery does not support inheritance with
multiple tables.

*Action*: Do not use UpdateAllQuery in this situation.

[.msg]#ECLIPSELINK-06109: The named fetch group (\{0}) is not defined at
the dscriptor level.# *Cause*: The named fetch group is not defined at
the descriptor level.

*Action*: Ensure the fetch group is defined in the descriptor.

[.msg]#ECLIPSELINK-06110: Read query cannot conform the unfetched
attribute (\{0}) of the partially fetched object in the unit of work
identity map.# *Cause*: Read query cannot conform to the unfetched
attribute of the partially fetched object in the unit of work identity
map.

*Action*: Do not use unfetched attribute conforming, or explicitly fetch
the attribute before conforming.

[.msg]#ECLIPSELINK-06111: The fetch group attribute (\{0}) is not
defined or not mapped.# *Cause*: The fetch group attribute is not
defined or mapped.

*Action*: Ensure that any attribute defined in a fetch group is defined
in the class and mapped.

[.msg]#ECLIPSELINK-06112: Fetch group cannot be set on report query.#
*Cause*: A fetch group was set on report query: fetch groups cannot be
set on report queries.

*Action*: Remove the fetch group setting on ReportQuery, or use
ReadObjectQuery or ReadObjectQuery instead.

[.msg]#ECLIPSELINK-06113: Fetch group cannot be used along with partial
attribute reading.# *Cause*: Fetch group was used together with partial
attribute reading: fetch groups cannot be used together with partial
attribute reading.

*Action*: Remove the partial attribute reading setting in the query.

[.msg]#ECLIPSELINK-06114: You must define a fetch group manager at
descriptor (\{0}) in order to set a fetch group on the query (\{1})#
*Cause*: A fetch group manager is not defined at the descriptor while
attempting to set a fetch group on a query.

*Action*: You must define a fetch group manager at the descriptor in
order to set a fetch group on the query.

[.msg]#ECLIPSELINK-06115: Queries on isolated classes, or queries set to
use exclusive connections, must not be executed on a ServerSession or,
in CMP, outside of a transaction.# *Cause*: An isolated query was
executed on a server session: queries on isolated classes, or queries
set to use exclusive connections, must not be executed on a
ServerSession or in CMP outside of a transaction.

*Action*: Do not execute queries on isolated classes or queries set to
use exclusive connections on a ServerSession or in CMP outside of a
transaction.

[.msg]#ECLIPSELINK-06116: No Call or Interaction was specified for the
attempted operation.# *Cause*: No call or interaction method was
specified for the attempted operation.

*Action*: Specify a call or interaction method.

[.msg]#ECLIPSELINK-06117: Can not set a query, that uses a cursored
result, to cache query results.# *Cause*: A query that uses a cursored
result to cache query results was set.

*Action*: Do not cache query results or do not use a cursor policy.

[.msg]#ECLIPSELINK-06118: A query on an Isolated class must not cache
query results on the query.# *Cause*: Query on an isolated class
attempted to cache query results on the query.

*Action*: Do not cache query results for a query on an isolated class.

[.msg]#ECLIPSELINK-06119: The join expression \{0} is not valid, or for
a mapping type that does not support joining.# *Cause*: The join
expression is not valid, or is for a mapping type that does not support
joining.

*Action*: Joining is supported only for one-one and one-many mappings.

[.msg]#ECLIPSELINK-06120: The partial attribute \{0} is not a valid
attribute of the class \{1}.# *Cause*: The partial attribute
attributeName is not a valid attribute of the class className.

*Action*: Ensure that this attribute exists, and is mapped.

[.msg]#ECLIPSELINK-06121: The query has not been defined correctly, the
expression builder is missing. For sub and parallel queries ensure the
queries builder is always on the left.# *Cause*: The query has not been
defined correctly: the expression builder is missing.

*Action*: Ensure the queries builder is always on the left for sub
queries and parallel queries.

[.msg]#ECLIPSELINK-06122: The expression is not a valid expression.
\{0}# *Cause*: Attempt to use an invalid expression expression.

*Action*: Ensure the correctness of the expression.

[.msg]#ECLIPSELINK-06123: The container class specified [\{0}] cannot be
used because the container needs to implement \{1}.# *Cause*: Invalid
container class specified: the container class className cannot be used,
because the container needs to implement interfaceName.

*Action*: Ensure that the class specified as a container implements the
correct interface.

[.msg]#ECLIPSELINK-06124: Required query of \{0}, found \{1}# *Cause*:
EclipseLink was expecting to find the query queryName, but instead found
an incorrect query queryName.

[.msg]#ECLIPSELINK-06124: Required query of \{0}, found \{1}# *Cause*:
EclipseLink was expecting to find the query queryName, but instead found
an incorrect query queryName.

*Action*: Provide the correct query.

[.msg]#ECLIPSELINK-06125: ReadQuery.clearQueryResults() can no longer be
called. The call to clearQueryResults now requires that the session be
provided. clearQueryResults(session) should be called.# *Cause*: The
ReadQuery method clearQueryResults() was called: this method cannot be
called anymore. The call to the clearQueryResults method now requires
that the session be provided.

*Action*: Call the ReadQuery method clearQueryResults(session).

[.msg]#ECLIPSELINK-06126: A query is being executed that uses both
conforming and cached query results. These two settings are
incompatible.# *Cause*: A query is being executed that uses both
conforming and cached query results. These two settings are
incompatible.

*Action*: Ensure that the query uses either conforming or cached query
results.

[.msg]#ECLIPSELINK-06127: A reflective call failed on the EclipseLink
class \{0}, your environment must be set up to allow Java reflection.#
*Cause*: A reflective call failed on the EclipseLink class classNAME.

*Action*: Set up your environment to allow Java reflection

[.msg]#ECLIPSELINK-06128: Batch Reading is not supported on Queries
using custom Calls.# *Cause*: Attempt to use batch reading on a query
using a custom call: batch reading is not supported on queries using
custom calls.

*Action*: Do not use batch reading on queries using custom calls.

[.msg]#ECLIPSELINK-06129: Refreshing is not possible if the query does
not go to the database.# *Cause*: Attempt to refreshing the query that
does not go to the database. This is not possible.

*Action*: Avoid refreshing queries that do not go to the database.

== Validation Exceptions (7001 – 7200)

`+ValidationException+` is a development exception that is raised when
an incorrect state is detected or an API is used incorrectly.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-7]##*_Validation Exception_*

`+EXCEPTION [ECLIPSELINK – 7008]: org.eclipse.persistence.exceptions.ValidationException+`
`+EXCEPTION DESCRIPTION: The Java type javaClass is not a valid database type. The Java type of the field to be written to the database has no corresponding type on the database.+`

[.msg]#ECLIPSELINK-07001: You must login to the ServerSession before
acquiring ClientSessions.# *Cause*: Attempt to allocate client sessions
before logging in to the server.

*Action*: Ensure you have called login method on your server session or
database session. This error also appears in multi-threaded environments
as a result of concurrency issues. Check that all your threads are
synchronized.

[.msg]#ECLIPSELINK-07002: The pool named [\{0}] does not exist.#
*Cause*: The pool name used while acquiring client session from the
server session does not exist.

*Action*: Verify the pool name given while acquiring client session and
all the existing pools on the server session.

[.msg]#ECLIPSELINK-07003: Max size must be greater than min size.#
*Cause*: The maximum number of connections in a connection pool is less
than the minimum number of connections. The connection pool size must be
greater than the minimum number of connections.

*Action*: Check addConnectionPool(String poolName, JDBCLogin login, int
minNumberOfConnections, int maxNumberOfConnections) method on the server
session.

[.msg]#ECLIPSELINK-07004: Pools must be configured before login.#
*Cause*: Attempt to add connection pools after logging in to the server
session: pools must all be added before login on the server session has
been done. Once logged in, you cannot add pools.

*Action*: Check addConnectionPool(String poolName, JDBCLogin login, int
minNumberOfConnections, int maxNumberOfConnections) on server session.
This method should be called before logging in on the server session.

[.msg]#ECLIPSELINK-07008: The Java type [\{0}] is not a valid database
type.# *Cause*: The Java type javaClass is not a valid database type.
The Java type of the field to be written to the database has no
corresponding type on the database.

*Action*: Check the table or stored procedure definition.

[.msg]#ECLIPSELINK-07009: Missing descriptor for [\{0}]. Verify that the
descriptor has been properly registered with the Session.# *Cause*: The
descriptor className is not found in the session.

*Action*: Ensure that the related descriptor to the class was properly
registered with the session.

[.msg]#ECLIPSELINK-07010: Start index is out of range.# *Cause*: This is
an EclipseLink development exception and you should never encounter this
problem. It happens when a copy of a vector is created with a start and
end index.

*Action*: Report this problem to Oracle Support Services.

[.msg]#ECLIPSELINK-07011: Stop index is out of range.# *Cause*: This is
an EclipseLink development exception and you should never encounter this
problem. It happens when a copy of a vector is created with a start and
end index.

*Action*: Report this problem to Oracle Support Services.

[.msg]#ECLIPSELINK-07012: Fatal error occurred.# *Cause*: This is an
EclipseLink development exception and you should never encounter this
problem. It happens when test cases are executed.

*Action*: Report this problem to Oracle Support Services. This error
commonly occurs if you attempt to call the commit method on an invalid
(or previously committed) unit of work. If cannotCommitUOWAgain method
of ValidationException appears in the stack trace, verify that the
commit method was called on valid UnitOfWork instances.

[.msg]#ECLIPSELINK-07013: You are using the deprecated SessionManager
API and no ECLIPSELINKLink.properties file could be found in your
classpath. No sessions could be read in from file.# *Cause*: The
toplink.properties file cannot be found on the system classpath.

*Action*: Ensure that there is a toplink.properties file located on the
system classpath.

[.msg]#ECLIPSELINK-07017: Child descriptors do not have an identity map,
they share their parent’’s# *Cause*: An identity map is added to the
child descriptor. A child descriptor shares its parent’s identity map.

*Action*: Check the child descriptor and remove the identity map from
it.

[.msg]#ECLIPSELINK-07018: File error.# *Cause*: You should never
encounter this problem. It happens when test cases are executed.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07023: Incorrect login instance provided. A
DatabaseLogin must be provided.# *Cause*: The login instance provided to
the login method is incorrect. A JDBCLogin must be provided.

*Action*: Use a JDBCLogin.

[.msg]#ECLIPSELINK-07024: Invalid merge policy.# *Cause*: This is an
EclipseLink development exception and you should never encounter it.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07025: The only valid keys for DatabaseRows are
Strings and DatabaseFields.# *Cause*: The key on the database row is not
either of type String or of type DatabaseField.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07027: The sequence named [\{0}] is setup
incorrectly. Its increment does not match its pre-allocation size.#
*Cause*: The sequence sequenceName is set up incorrectly: increment does
not match preallocation size.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07028: writeObject() is not allowed within a
UnitOfWork.# *Cause*: Attempt to use writeObject() method in a
UnitOfWork.

*Action*: Ensure that a writeObject() method is not in the UnitOfWork.

[.msg]#ECLIPSELINK-07030: You cannot set read pool size after login.#
*Cause*: Attempt to set read pool size after the server session has
already been logged in.

*Action*: Set the pool size before login.

[.msg]#ECLIPSELINK-07031: You cannot add descriptors to a
SessionBroker.# *Cause*: Attempt to add a descriptor directly to a
session broker.

*Action*: Descriptors are added to the sessions contained in the session
broker.

[.msg]#ECLIPSELINK-07032: There is no session registered for the class
[\{0}].# *Cause*: The descriptor related to the domain class domainClass
was not found in any of the sessions registered in the session broker.

*Action*: Check the sessions.

[.msg]#ECLIPSELINK-07033: There is no session registered with the name
[\{0}].# *Cause*: A session sessionName is not registered in the session
broker.

*Action*: Check the session broker.

[.msg]#ECLIPSELINK-07038: Error while logging message to Session log.#
*Cause*: Error while logging message to session’s log.

*Action*: Check the internal exception.

[.msg]#ECLIPSELINK-07039: Cannot remove from the set of read-only
classes in a nested UnitOfWork. \{0}A nested UnitOfWork’'`s set of
read-only classes must be equal to or a superset of its parent`'’s set
of read-only classes.# *Cause*: Attempt to remove from the set of
read-only classes in a nested unit of work. A nested unit of work’s set
of read-only classes must be equal to or be a superset of its parent’s
set of read-only classes.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07040: Cannot change the set of read-only classes in
a UnitOfWork after that UnitOfWork has been used. \{0}Changes to the
read-only set must be made when acquiring the UnitOfWork or immediately
after.# *Cause*: Attempt to change the set of read-only classes in a
unit of work after that unit of work has been used. Changes to the
read-only set must be made when acquiring the unit of work or
immediately after.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07042: Database platform class [\{0}] not found.#
*Cause*: The platform class className was not found and a reflection
exception is raised.

*Action*: Check the internal exception.

[.msg]#ECLIPSELINK-07043: [\{0}] does not have any tables to create on
the database.# *Cause*: A project project does not have any tables to
create on the database.

*Action*: Validate the project and tables you are attempting to create.

[.msg]#ECLIPSELINK-07044: The container class specified [\{0}] cannot be
used as a container because it does not implement Collection or Map.#
*Cause*: Illegal attempt to use the class className as the
container-this class does not implement the Collection or Map
interfaces.

*Action*: Implement either the Collection or Map interfaces in the
container class.

[.msg]#ECLIPSELINK-07047: The container specified [\{0}] does not
require keys. You tried to use the method [\{1}].# *Cause*: Invalid Map
class was specified for the container policy. The container specified
(of Class aPolicyContainerClass) does not require keys. You tried to use
the method methodName.

*Action*: Use map class that implements the Map interface.

[.msg]#ECLIPSELINK-07048: Neither the instance method or field named
[\{0}] exists for the item class [\{1}], and therefore cannot be used to
create a key for the Map.# *Cause*: The key method on the map container
policy is not defined. The instance method methodName does not exist in
the reference class className and therefore cannot be used to create a
key in a map. A map container policy represents the way to handle an
indexed collection of objects. Usually the key is the primary key of the
objects stored, so the policy needs to know the name of the primary key
getter method in order to extract it from each object using reflection.
For instance, a user might call policy.setKeyMethodName("`getId`").

*Action*: Check the second parameter of the useMapClass method of
DatabaseQuery.

[.msg]#ECLIPSELINK-07051: Missing attribute [\{1}] for descriptor
[\{0}], called from [\{2}]# *Cause*: Missing attribute attributeName for
descriptor descriptor called from methodName. This is an EclipseLink
development exception, and you should never encounter it.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07052: An attempt was made to use [\{0}] (with the
key method [\{1}]) as a container for a DirectCollectionMapping [\{0}].
The useMapClass() method cannot be used, only the useCollectionClass()
API is supported for DirectCollectionMappings.# *Cause*: The method
useMapClass was called on a DirectCollectionMapping. It is invalid to
call the useMapClass method on a DirectCollectionMapping. EclipseLink
cannot instantiate Java attributes mapped using a
DirectCollectionMapping with a map. The useMapClass method is supported
for OneToManyMapping and ManyToManyMapping. The Java 2 Collection
interface is supported using the useCollectionClass method.

*Action*: Use the useCollectionClass method. Do not call the useMapClass
method on DirectCollectionMapping.

[.msg]#ECLIPSELINK-07053: release() attempted on a Session that is not a
ClientSession. Only ClientSessions may be released.# *Cause*:
EclipseLink is unable to release a session that is not a client session.
Only client sessions can be released.

*Action*: Modify the code to ensure the client session is not released.

[.msg]#ECLIPSELINK-07054: acquire() attempted on a Session that is not a
ServerSession. ClientSessions may only be acquired from ServerSessions.#
*Cause*: EclipseLink is unable to acquire a session that is not a client
session. Client sessions can be acquired only from server sessions.

*Action*: Modify the code to ensure an acquire session is attempted only
from server sessions.

[.msg]#ECLIPSELINK-07055: Optimistic Locking is not supported with
stored procedure generation.# *Cause*: Attempt to use optimistic locking
with stored procedure generation. This is not supported.

*Action*: Do not use optimistic locking with stored procedure
generation.

[.msg]#ECLIPSELINK-07056: The wrong object was registered into the
UnitOfWork. The object [\{0}] should be the object from the parent cache
[\{1}].# *Cause*: The wrong object was registered into the unit of work.
It should be the object from the parent cache.

*Action*: Ensure that the object is from the parent cache.

[.msg]#ECLIPSELINK-07058: Invalid Connector [\{0}] (must be of type
DefaultConnector).# *Cause*: The connector selected is invalid and must
be of type DefaultConnector.

*Action*: Ensure that the connector is of type DefaultConnector.

[.msg]#ECLIPSELINK-07059: Invalid data source name [\{0}].# *Cause*:
Invalid data source name dsName.

*Action*: Verify the data source name.

[.msg]#ECLIPSELINK-07060: Cannot acquire data source [\{0}].# *Cause*:
EclipseLink is unable to acquire the data source with the name dsName,
or an error has occurred in setting up the data source.

*Action*: Verify the data source name. Check the nested SQL exception to
determine the cause of the error. Typical problems include:The
connection pool was not configured in your config.xml file.The driver is
not on the classpath.The user or password is incorrect.The database
server URL or driver name is not properly specified.

[.msg]#ECLIPSELINK-07061: Exception occurred within JTS.# *Cause*: An
exception occurred within the Java Transaction Service (JTS).

*Action*: Examine the JTS exception and see the JTS documentation.

[.msg]#ECLIPSELINK-07062: Field-level locking is not supported outside
of a UnitOfWork. To use field-level locking, a UnitOfWork must be used
for ALL writing.# *Cause*: Attempt to use FieldLevelLocking outside a
unit of work. This is not supported. In order to use field-level
locking, a unit of work must be used for all write operations.

*Action*: Use a unit of work for writing.

[.msg]#ECLIPSELINK-07063: Exception occurred within EJB container.#
*Cause*: An exception occurred within the EJB container.

*Action*: Examine the EJB exception and see the JTS documentation.

[.msg]#ECLIPSELINK-07064: Exception occurred in reflective EJB primary
key extraction. Please ensure your primary key object is defined
correctly. \{2}Key: [\{0}] \{2}Bean: [\{1}]# *Cause*: An exception
occurred in the reflective enterprise bean primary key extraction.

*Action*: Ensure that your primary key object is defined correctly.

[.msg]#ECLIPSELINK-07065: The remote class for the bean cannot be loaded
or found. Ensure that the correct class loader is set. \{2}Bean: [\{0}]
\{2}Remote Class: [\{1}]# *Cause*: The remote class for the bean cannot
be loaded or found.

*Action*: Ensure that the correct class loader is set properly.

[.msg]#ECLIPSELINK-07066: Cannot create or remove beans unless a JTS
transaction is present. \{1}Bean: [\{0}]# *Cause*: Attempt to create or
remove an enterprise bean outside of a transaction: EclipseLink is
unable to create or remove enterprise beans unless a JTS transaction is
present, bean=bean.

*Action*: Ensure that the JTS transaction is present.

[.msg]#ECLIPSELINK-07068: The project class [\{0}] was not found for the
project [\{1}] using the default class loader.# *Cause*: The platform
class platformName was not found for the project projectName using the
default class loader.

*Action*: Validate the project and platform.

[.msg]#ECLIPSELINK-07069: An exception occurred looking up or inovking
the project amendment method, ’'`\{0}`'’ on the class ’'`\{1}`'’.#
*Cause*: An exception occurred while looking up or invoking the project
amendment method amendmentMethod on the class amendmentClass.

*Action*: Validate the amendment method and class.

[.msg]#ECLIPSELINK-07070: an EclipseLINKLink.properties resource bundle
must be located on the CLASSPATH in an EclipseLink directory.# *Cause*:
Attempt to load toplink.properties resource bundle outside the
classpath: the resource bundle must be located on the classpath in an
EclipseLink directory.

*Action*: Validate the classpath and the location of the EclipseLink
resource bundle.

[.msg]#ECLIPSELINK-07071: Cannot use input/output parameters without
using binding.# *Cause*: Attempt to use input or output parameters
without using binding.

*Action*: Use binding on the StoredProcedureCall.

[.msg]#ECLIPSELINK-07072: The database platform class [\{0}] was not
found for the project [\{1}] using the default class loader.# *Cause*:
SessionManager failed to load the class identified by the value
associated with properties platform-class or
external-transaction-controller-class during initialization when it
loads the EclipseLink session common properties from the EclipseLink
global properties file (sessions.xml for non-EJB applications, or
toplink-ejb-jar.xml for EJB applications).

*Action*: Ensure that your EclipseLink global properties file is
correctly configured. Pay particular attention to the platform-class and
external-transaction-controller-class properties.

[.msg]#ECLIPSELINK-07073: The Oracle object type with type name [\{0}]
is not defined.# *Cause*: The Oracle object type with type name typeName
is not defined.

*Action*: Ensure that the Oracle object type is defined.

[.msg]#ECLIPSELINK-07074: The Oracle object type name [\{0}] is not
defined.# *Cause*: The Oracle object type typeName is not defined.

*Action*: Ensure that the Oracle object type is defined.

[.msg]#ECLIPSELINK-07075: Maximum size is not defined for the Oracle
VARRAY type [\{0}]. A maximum size must be defined.# *Cause*: The Oracle
VARRAY type typeName maximum size is not defined.

*Action*: Verify the maximum size for the Oracle VARRAY.

[.msg]#ECLIPSELINK-07076: When generating the project class, the
project’’s descriptors must not be initialized. \{1}Descriptor: [\{0}]#
*Cause*: Attempt to generate a project class while descriptors have
already been initialized: when generating the project class, the
descriptors must not be initialized.

*Action*: Ensure that the descriptors are not initialized before
generating the project class.

[.msg]#ECLIPSELINK-07077: The home interface [\{0}], specified during
creation of the BMPWrapperPolicy, does not contain a correct
findByPrimaryKey() method. A findByPrimaryKey() method must exist that
takes the PrimaryKey class for this bean.# *Cause*: The home interface
toString method specified during creation of BMPWrapperPolicy does not
contain a correct findByPrimaryKey method. A findByPrimaryKey method
must exist that takes the PrimaryKey class for this bean.

*Action*: Ensure that a findByPrimaryKey method exists and is correct.

[.msg]#ECLIPSELINK-07078: The "`sessionName`" [\{0}], specified on the
deployment descriptor for [\{1}], does not match any session specified
in the EclipseLink properties file.# *Cause*: The sessionName specified
on the deployment descriptor does not match any session specified in the
toplink.properties file.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07079: The descriptor for [\{0}] was not found in the
session [\{1}]. Check the project being used for this session.# *Cause*:
The descriptor was not found in the session.

*Action*: Check the project being used for this session.

[.msg]#ECLIPSELINK-07080: A FinderException was thrown when trying to
load [\{0}], of class [\{1}], with primary key [\{2}].# *Cause*: A
FinderException is raised when attempting to load an object from the
class with the primary key.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07081: The aggregate object [\{0}] cannot be directly
registered in the UnitOfWork. It must be associated with the source
(owner) object.# *Cause*: Attempt to register an aggregate object
directly in the unit of work. This is not supported. The aggregate
object must be associated with the source (owner) object.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07082: The EclipseLink properties file [\{0}]
specified multiple project files for the server named [\{1}]. Please
specify one of [projectClass], [projectFile], or [xmlProjectFile].#
*Cause*: The toplink.properties file specified multiple project files
for the server. Only one project file can be specified.

*Action*: Specify either projectClass, projectFile, or xmlProjectFile.

[.msg]#ECLIPSELINK-07083: The EclipseLink properties file [\{0}] did not
include any information on the EclipseLink project to use for the server
named [\{1}]. Please specify one of [projectClass], [projectFile], or
[xmlProjectFile].# *Cause*: The toplink.properties file does not include
any information on the EclipseLink project to use for the server. One
project file must be specified.

*Action*: Specify either projectClass, projectFile, or xmlProjectFile.

[.msg]#ECLIPSELINK-07084: The file [\{0}] is not a valid type for
reading. ProjectReader must be given the deployed XML Project file.#
*Cause*: The specified file is not a valid type for reading.
ProjectReader must be given the deployed XML project file.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07085: At least one sub session need to be defined in
the EclipseLink session broker \{0}# *Cause*: EclipseLink is unable to
create an instance of the external transaction controller specified in
the properties file.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07086: The session type ’'`\{0}`'’ of the session
name ’'`\{1}`'’ was not defined properly.# *Cause*: The session manager
cannot load the class corresponding to the session’s type class name.

*Action*: Ensure that the class name of the session’s type is fully
qualified in the sessions.xml file or toplink.properties file.

[.msg]#ECLIPSELINK-07087: The session type ’'`\{0}`'’ was not found for
the ’'`\{1}`'’ using default class loader.# *Cause*: The session manager
cannot load the class corresponding to the session’s type class name.

*Action*: Ensure that the class name of the session’s type is fully
qualified in the sessions.xml file or toplink.properties file.

[.msg]#ECLIPSELINK-07088: Cannot create an instance of the external
transaction controller [\{0}], specified in the properties file.#
*Cause*: The session manager cannot load the class corresponding to the
external transaction controller’s class name.

*Action*: Ensure that the class name of the external transaction
controller is valid and fully qualified in the sessions.xml file or
toplink.properties file.

[.msg]#ECLIPSELINK-07089: An exception occurred looking up or invoking
the session amendment method [\{0}] on the class [\{1}] with parameters
[\{2}].# *Cause*: The session manager cannot load the class
corresponding to the amendment class name, or it cannot load the method
on the amendment class corresponding to the amendment method name.

*Action*: Ensure that the class name of the amendment class is fully
qualified, and the amendment method exists in the amendment class in the
sessions.xml file or toplink.properties file.

[.msg]#ECLIPSELINK-07091: Cannot set listener classes!# *Cause*:
EclipseLink is unable to create the listener class that implements
SessionEventListener for the internal use of SessionXMLProject.

*Action*: Contact Oracle Support Services.

[.msg]#ECLIPSELINK-07092: Cannot add a query whose types conflict with
an existing query. Query To Be Added: [\{0}] is named: [\{1}] with
arguments [\{2}].The existing conflicting query: [\{3}] is named: [\{4}]
with arguments: [\{5}].# *Cause*: EclipseLink has detected a conflict
between a custom query with the same name and arguments to a session.

*Action*: Ensure that no query is added to the session more than once or
change the query name so that the query can be distinguished from
others.

[.msg]#ECLIPSELINK-07093: In the query named [\{0}], the class [\{2}]
for query argument named [\{1}] cannot be found. Please include the
missing class on your classpath.# *Cause*: EclipseLink is unable to
create an instance of the query argument type.

*Action*: Ensure that the argument type is a fully qualified class name
and the argument class is included in the classpath environment.

[.msg]#ECLIPSELINK-07095: The sessions.xml resource [\{0}] was not found
on the resource path. Check that the resource name/path and classloader
passed to the SessionManager.getSession are correct. The sessions.xml
should be included in the root of the application’s deployed jar, if the
sessions.xml is deployed in a sub-directory in the application’s jar
ensure that the correct resource path using "`/`" not "`\`" is used.#
*Cause*: The sessions.xml or toplink.properties file cannot be loaded.

*Action*: Ensure that the path to either of the files exists on the
classpath environment. The sessions.xml should be included in the root
of the deployed JAR file. When using a WAR file, the sessions.xml file
should be located in the WEB-INF/classes directory. When using EJB 3.0,
EclipseLink automatically loads the ejb3-toplink-sessions.xml file.

[.msg]#ECLIPSELINK-07096: Cannot use commit() method to commit
UnitOfWork again.# *Cause*: EclipseLink cannot invoke commit method on
an inactive unit of work that was committed or released.

*Action*: Ensure you invoke commit method on a new unit of work or
invoke commitAndResume method so that the unit of work can be reused.
For more information about the commitAndResume method, see Oracle
EclipseLink API Reference.

[.msg]#ECLIPSELINK-07097: Operation not supported: [\{0}].# *Cause*:
EclipseLink cannot invoke an unsupported operation on an object.

*Action*: Do not use the operation indicated in the stack trace.

[.msg]#ECLIPSELINK-07099: The deployment project xml resource [\{0}] was
not found on the resource path. Check that the resource name/path and
classloader passed to the XMLProjectReader are correct. The project xml
should be included in the root of the application’s deployed jar, if the
project xml is deployed in a sub-directory in the application’s jar
ensure that the correct resource path using "`/`" not "`\`" is used.#
*Cause*: The file name specified for the XML-based project is incorrect.

*Action*: Verify the name and location of the file.

[.msg]#ECLIPSELINK-07101: No "`meta-inf/toplink-ejb-jar.xml`" could be
found in your classpath. The CMP session could not be read in from
file.# *Cause*: The toplink-ejb-jar.xml file was not found.

*Action*: Ensure that the file is on your classpath.

[.msg]#ECLIPSELINK-07102: Encountered a null value for a cache key while
attempting to remove\{2}an object from the identity map:
[\{0}]\{2}containing an object of class: [\{1}] (or a class in this
hierarchy)\{2}The most likely cause of this situation is that the object
has already been garbage-\{2}collected and therefore does not exist
within the identity map.\{2}Please consider using an alternative
identity map to prevent this situation.\{2}For more details regarding
identity maps, please refer to the EclipseLink documentation.# *Cause*:
Encountered a null value for a cache key while attempting to remove an
object from the identity map. The most likely cause of this situation is
that the object has already been garbage-collected and therefore does
not exist within the identity map.

*Action*: Ignore. The removeFromIdentityMap method of the Session is
intended to allow garbage collection, which has already been done.

[.msg]#ECLIPSELINK-07103: A null reference was encountered while
attempting to invoke\{1}method: [\{0}] on an object which uses proxy
indirection.\{1}Please check that this object is not null before
invoking its methods.# *Cause*: A null reference was encountered while
attempting to invoke a method on an object that uses proxy indirection.

*Action*: Check that this object is not null before invoking its
methods.

[.msg]#ECLIPSELINK-07104: Sequencing login should not use External
Transaction Controller.# *Cause*: A separate connection(s) for
sequencing was requested, but the sequencing login uses the external
transaction controller.

*Action*: Either provide a sequencing login that does not use an
external transaction controller or do not use separate connection(s) for
sequencing.

[.msg]#ECLIPSELINK-07105: Error encountered converting encryptiong
class: [\{0}]# *Cause*: Error encountered while converting encryption
class.

*Action*: Ensure the encryption class name is correctly specified in the
sessions.xml file and that the encryption class specified is available
on the classpath. A common reason for this exception is the usage of JDK
1.3 and earlier versions. The EclipseLink JCE encryption mechanism
requires JDK 1.4 and later (or JDK 1.3 configured with the JCE plug-in)
to function properly.

[.msg]#ECLIPSELINK-07106: Error encountered during string encryption.#
*Cause*: Error encountered during password string encryption.

*Action*: An error is raised while trying to encrypt the password
string. A common reason for this exception is the usage of JDK 1.3 and
earlier versions. The EclipseLink JCE encryption mechanism requires JDK
1.4 and later (or JDK 1.3 configured with the JCE plug-in) to function
properly.

[.msg]#ECLIPSELINK-07107: Error encountered during string decryption.#
*Cause*: Error encountered during password string decryption.

*Action*: An exception was raised while trying to decrypt the password
string. A common reason for this exception is the usage of JDK 1.3 and
earlier versions. The EclipseLink JCE encryption mechanism requires JDK
1.4 and later (or JDK 1.3 configured with the JCE plug-in) to function
properly.

[.msg]#ECLIPSELINK-07108: This operation is not supported for
non-relational platforms.# *Cause*: Attempt to use an operation that is
not supported for nonrelational platforms.

*Action*: Do not use this operation on the current platform, or use a
relational database platform.

[.msg]#ECLIPSELINK-07109: The login in the project used to create the
session is null, it must be a valid login.# *Cause*: The login in the
project used to create the session is null meaning no login was
specified for the EclipseLink project. The login used for the project
must be a valid login.

*Action*: Add login information using EclipseLink Workbench or using
Java code.

[.msg]#ECLIPSELINK-07110: At present HistoricalSession only works with
Oracle 9R2 or later databases, as it uses Oracle’s Flashback feature.#
*Cause*: Attempt to use a HistoricalSession with a non-Oracle database.
At present, HistoricalSession only works with Oracle databases that have
a Flashback feature (Oracle database 9.2.0.4 or later).Generic history
support (see org.eclipse.persistence.history.HistoryPolicy) works for
any database. If a HistoryPolicy is incorrectly set, EclipseLink may be
defaulting to using flashback instead. An AsOfSCNClause is implicitly
flashback only.

*Action*: Ensure that the HistoryPolicy is set correctly.

[.msg]#ECLIPSELINK-07111: You may not acquire a HistoricalSession from a
UnitOfWork, another HistoricalSession, a ServerSession, or a
ServerSessionBroker. You may acquire one from a regular session, a
ClientSession, or a ClientSessionBroker.# *Cause*: Invalid attempt to
acquire a HistoricalSession: you may not acquire a HistoricalSession
from a unit of work, another HistoricalSession, a ServerSession, or a
ServerSessionBroker. You may acquire a HistoricalSession from a regular
session, a ClientSession, or a ClientSessionBroker.

*Action*: To recover objects, read the objects in both a
HistoricalSession and UnitOfWork, and call
mergeCloneWithReferences(historicalObject) method on the UnitOfWork.

[.msg]#ECLIPSELINK-07112: You have specified that Toplink use the
feature : \{0}, but this feature is not available in the currently
running JDK version :\{1}.# *Cause*: Attempt to use an EclipseLink
feature that is not available in the current JDK version.

*Action*: You must use the version of the JDK that supports this
feature.

[.msg]#ECLIPSELINK-07113: \{0} does not support call with returning.#
*Cause*: Attempt to use an unsupported call with returning for a
platform.

*Action*: Set stored procedures with output parameters in
setInsertQuery, setInsertCall, setUpdateQuery, or setUpdateCall methods
of the DescriptorQueryManager.

[.msg]#ECLIPSELINK-07114: Isolated Data is not currently supported
within a Client Session Broker. Session named \{0} contains descriptors
representing isolated data.# *Cause*: Attempt to use isolated data
within a ClientSessionBroker: isolated data is not currently supported
within a ClientSessionBroker. Session contains descriptors representing
isolated data.

*Action*: Ensure that isolated data is not used.

[.msg]#ECLIPSELINK-07115: A Exclusive Connection cannot be used for
ClientSession reads without isolated data. Please update the
ConnectionPolicy, used, to remove ExclusiveConnection configuration or
the project to set certain data to be exclusive.# *Cause*: Attempt to
use ExclusiveConnection for ClientSession reads without isolated data.
This is not supported.

*Action*: You must update the ConnectionPolicy used to remove
ExclusiveConnection configuration, or the project to set certain data to
be exclusive.

[.msg]#ECLIPSELINK-07116: Invalid arguments are used. Please refer to
public API of the calling method and use valid values for the
arguments.# *Cause*: Invalid arguments are used in the method.

*Action*: Refer to the public API of the calling method and use valid
values for the arguments.

[.msg]#ECLIPSELINK-07117: There is an attempt to use more than one
cursor in SQLCall \{0}# *Cause*: Attempt to use more than one cursor in
a SQLCall.

*Action*: EclipseLink currently supports only one cursor per call.

[.msg]#ECLIPSELINK-07118: setCustomSQLArgumentType method was called on
SQLCall \{0}, but this call doesn’t use custom SQL# *Cause*: The
setCustomSQLArgumentType method was invoked on SQLCall, but this method
does not use custom SQL.

*Action*: Don’t call this method on SQLCall that does not use custom
SQL.

[.msg]#ECLIPSELINK-07119: Unprepared SQLCall \{0} attempted translation#
*Cause*: Unprepared SQLCall attempted translation.

*Action*: SQLCall must be prepared before translation.

[.msg]#ECLIPSELINK-07120: Parameter \{0} in SQLCall \{1} cannot be used
as a cursor, because it is has parameter type other than OUT# *Cause*:
Attempt to use parameter in SQLCall as a cursor, but this parameter is
of type other than OUT.

*Action*: Ensure that the parameter used as a cursor has parameter type
OUT.

[.msg]#ECLIPSELINK-07121: \{0} does not support stored functions#
*Cause*: Attempt to use stored functions for a platform that does not
support stored functions.

*Action*: Do not define stored functions on this platform.

[.msg]#ECLIPSELINK-07122: The exclusive connection associated with the
session is unavailable for the query on \{0}# *Cause*: The exclusive
connection associated with the session is unavailable for the query on
the object.Isolated objects with indirection read through an
ExclusiveIsolatedClientSession must not have indirection triggered after
the ExclusiveIsolatedClientSession has been released.

*Action*: Reread the objects through the current
ExclusiveIsolatedClientSession.

[.msg]#ECLIPSELINK-07123: A successful writeChanges() has been called on
this UnitOfWork. As the commit process has been started but not yet
finalized, the only supported operations now are commit,
commitAndResume, release, any non-object level query or SQLCall
execution. The operation \{0} is not allowed at this time.# *Cause*:
Attempt to perform an operation that is not allowed at this time: a
successful writeChanges operation has been called on this UnitOfWork. As
the commit process has been started, but not yet finalized, the only
supported operations now are commit, commitAndResume, release, any
nonobject level query, or SQLCall execution.

*Action*: Execute one of the supported operations to continue.

[.msg]#ECLIPSELINK-07124: An unsuccessful writeChanges() has been called
on this UnitOfWork. Given the danger that partial changes have been
written to the datastore but not rolled back (if inside external
transaction), the only supported operations now are release, global
transaction rollback, any non-object level query or SQLCall execution.
The operation \{0} was attempted.# *Cause*: Attempt to perform an
operation that is not allowed at this time: an unsuccessful writeChanges
operation has been called on this UnitOfWork. Given the possibility that
partial changes have been written to the data store but not rolled back
(if inside external transaction), the only supported operations now are
release, global transaction rollback, any nonobject level query or
SQLCall execution.

*Action*: Determine the cause of the original failure and retry in a new
UnitOfWork.

[.msg]#ECLIPSELINK-07125: Once the UnitOfWork has been committed and/or
released, no further operation should be performed on it. The operation
\{0} was attempted on it.# *Cause*: Attempt to perform an operation on
an inactive unit of work: once the UnitOfWork has been committed and/or
released, no further operation should be performed on it.

*Action*: Acquire a new UnitOfWork, or use the commitAndResume method
instead of commit method in the future.

[.msg]#ECLIPSELINK-07126: writeChanges cannot be called on a
NestedUnitOfWork. A nested UnitOfWork never writes changes directly to
the datastore, only the parent UnitOfWork does.# *Cause*: Attempt to
call a writeChanges method on a NestedUnitOfWork. This is not supported:
a nested UnitOfWork never writes changes directly to the data store,
only the parent UnitOfWork does.

*Action*: Call the commit method instead, and then the writeChanges
method on the parent UnitOfWork.

[.msg]#ECLIPSELINK-07127: You can only writes changes to the datastore
once, just as you can only call commit once.# *Cause*: Attempt to write
changes to the data store more than once: you can only write changes to
the data store once.

*Action*: You must either roll back the transaction, or call the commit
method on this UnitOfWork and start a new transaction.

[.msg]#ECLIPSELINK-07128: Session [\{0}] is already logged in.# *Cause*:
Attempt to log in to a session more than once.

*Action*: Do not try to login again.

[.msg]#ECLIPSELINK-07129: The method’’s arguments cannot have null
value.# *Cause*: Attempt to use null values for arguments in a method
that cannot have null values.

*Action*: Ensure that the method’s arguments do not have a null value.

[.msg]#ECLIPSELINK-07130: Nested unit of work is not supported for
attribute change tracking.# *Cause*: Attempt to use a nested UnitOfWork
with attribute change tracking. This is not supported.

*Action*: Do not use a nested UnitOfWork with attribute change tracking.

[.msg]#ECLIPSELINK-07131: \{0} is the wrong type. The collection change
event type has to be add or remove.# *Cause*: The collection change
event is of the wrong type. The collection change event type has to be
added or removed.

*Action*: Ensure that the collection change event type used is defined
in CollectionChangeEvent.

[.msg]#ECLIPSELINK-07132: \{0} is the wrong event class. Only
PropertyChangeEvent and CollectionChangeEvent are supported.# *Cause*:
Wrong event class. Only PropertyChangeEvent and CollectionChangeEvent
classes are supported.

*Action*: Ensure that the event class is either PropertyChangeEvent or
CollectionChangeEvent.

[.msg]#ECLIPSELINK-07133: Old commit is not supported for attribute
change tracking.# *Cause*: Attempt to use old commit for attribute
change tracking. This is not supported.

*Action*: Do not try to use attribute change tracking with an old
commit.

[.msg]#ECLIPSELINK-07134: Server platform \{0} is read only after
login.# *Cause*: Attempt to make changes to the server platform after
login: the server platform is read-only after login.

*Action*: Changes to the server platform must be made before login. You
must either:CMP application: define a class that implements
oracle.toplink.ejb.cmp.DeploymentCustomization, and customize its public
String beforeLoginCustomization(Session session) method to change your
server platform. Consult the documentation for defining a customization
class in your orion-ejb-jar.xml file.Non-CMP/POJO application: define a
subclass of org.eclipse.persistence.sessions.SessionEventAdapter, and
override the public void preLogin(SessionEvent event) method to change
your server platform. The session is contained in the event. Consult the
documentation for sessions.xml and using SessionEventAdapter.

[.msg]#ECLIPSELINK-07135: You cannot commit and resume a unit of work
containing any modify all queries# *Cause*: Attempt to commit and resume
a UnitOfWork containing an UpdateAllQuery. This is not supported.

*Action*: You must either commit and continue in a new UnitOfWork, or do
not use UpdateAllQuery.

[.msg]#ECLIPSELINK-07136: Nested unit of work is not supported for a
modify all query# *Cause*: Attempt to use a nested UnitOfWork for an
UpdateAll query. This is not supported.

*Action*: Do not use a nested UnitOfWork for an UpdateAllQuery.

[.msg]#ECLIPSELINK-07137: The object is partially fetched (using fecth
group), the unfetched attribute (\{0}) is not editable.# *Cause*:
Attempt to edit an unfetched attribute: the object is partially fetched
(using fetch group), the unfetched attribute is not editable.

*Action*: Do not edit the unfetched attribute, or explicitly fetch the
attribute before editing it.

[.msg]#ECLIPSELINK-07139: Modify all queries cannot be issued within a
unit of work containing other write operations.# *Cause*: Attempt to
issue an UpdateAll query within a UnitOfWork containing other write
operations.

*Action*: Do not use UpdateAllQuery within a UnitOfWork containing other
write operations.

[.msg]#ECLIPSELINK-07140: Sequence type \{0} doesn’’t have method \{1}.#
*Cause*: Sequence type does not have the method.

*Action*: Do not call this method on this type of sequence.

[.msg]#ECLIPSELINK-07144: \{0}: platform \{1} doesn’’t support \{2}.#
*Cause*: Platform does not support sequence.

*Action*: Do not use this sequence type on this platform.

[.msg]#ECLIPSELINK-07145: \{2} attempts to connect to sequence \{0}, but
it is already connected to \{1}. Likely the two sessions share the
DatasourcePlatform object# *Cause*: Two attempts have been made to
connect to sequence, but the sequence is already connected to a
platform. Likely the two sessions share the DatasourcePlatform object.

*Action*: Ensure that the sequence is used by a single session only.

[.msg]#ECLIPSELINK-07146: QuerySequence \{1} doesn’’t have select
query.# *Cause*: QuerySequence does not have select query.

*Action*: Ensure that the sequence has a select query.

[.msg]#ECLIPSELINK-07147: Platform \{0} cannot create platform default
sequence - it doesn’’t override createPlatformDefaultSequence method#
*Cause*: Attempt to create platform default sequence by a platform that
does not override the createPlatformDefaultSequence method.

*Action*: You must either override the createPlatformDefaultSequence
method on the platform, or explicitly set default sequence by calling
setDefaultSequence on DatasourceLogin.

[.msg]#ECLIPSELINK-07148: commitAndResume() cannot be used with a
JTA/synchronized unit of work.# *Cause*: Attempt to use
commitAndResume() method with a JTA or a synchronized unit of work.

*Action*: Do not use commitAndResume() with a JTA or a synchronized unit
of work.

[.msg]#ECLIPSELINK-07149: The composite primary key attribute [\{2}] of
type [\{4}] on entity class [\{0}] should be of the same type as defined
on its primary key class [\{1}]. That is, it should be of type [\{3}].#
*Cause*: Attempt to provide an invalid specification of the composite
primary key: the names of the primary key fields or properties in the
primary key class PKClassName and those of the entity bean class
ClassName must correspond and their types must be the same.

*Action*: Ensure that the names of the primary key fields or properties
in the primary key class PKClassName and those of the entity bean class
ClassName correspond, and their types are the same.

[.msg]#ECLIPSELINK-07150: Invalid composite primary key specification.
The names of the primary key fields or properties in the primary key
class [\{1}] and those of the entity bean class [\{0}] must correspond
and their types must be the same. Also, ensure that you have specified
id elements for the corresponding attributes in XML and/or an @Id on the
corresponding fields or properties of the entity class.# *Cause*:
Attempt to specify an invalid LAZY fetch type on an attribute
attributeName within entity class ClassName.

*Action*: Provide the fetch type other than LAZY on an attribute
attributeName within entity class ClassName.

[.msg]#ECLIPSELINK-07151: The type [\{1}] for the attribute [\{0}] on
the entity class [\{2}] is not a valid type for an enumerated mapping.
The attribute must be defined as a Java enum.# *Cause*: An invalid EJB
3.0 annotation annotation has been specified in the entity class
ClassName on accessor method methodName. It is not supported.

*Action*: Specify a valid annotation on this accessor method.

[.msg]#ECLIPSELINK-07152: Table per class inheritance is not supported.
Entity class [\{0}].# *Cause*: Table per class inheritance is not
supported. Entity class ClassName.

*Action*: Use different approach.

[.msg]#ECLIPSELINK-07153: Mapping annotations cannot be applied to
fields or properties that are transient or have a @Transient specified.
[\{0}] is in violation of this restriction.# *Cause*: The descriptor
named query query already exists. Named query names must be unique.

*Action*: Provide a unique name for the query.

[.msg]#ECLIPSELINK-07154: The attribute [\{3}] in entity class [\{2}]
has a mappedBy value of [\{1}] which does not exist in its owning entity
class [\{0}]. If the owning entity class is a @MappedSuperclass, this is
invalid, and your attribute should reference the correct subclass.#
*Cause*: An annotation @AssociationTable was not found on either the
owning mapping class ClassName, or nonowning mapping class
DifferentClassName for the @ManyToMany annotation.

*Action*: Ensure that the annotation @AssociationTable exists.

[.msg]#ECLIPSELINK-07155: The type [\{1}] for the attribute [\{0}] on
the entity class [\{2}] is not a valid type for a serialized mapping.
The attribute type must implement the Serializable interface.# *Cause*:
An annotation @AttributeOverride columns was not specified on a mapping
mapping from entity class ClassName.

*Action*: Specify this annotation.

[.msg]#ECLIPSELINK-07156: Unable to find the class named [\{0}]. Ensure
the class name/path is correct and available to the classloader.#
*Cause*: EclipseLink was unable to find the class ClassName. Ensure the
class name/path is correct and available to the class loader.

*Action*: Ensure the class name and/or path is correct and available to
the class loader.

[.msg]#ECLIPSELINK-07157: Entity class [\{0}] must use a @JoinColumn
instead of @Column to map its relationship attribute [\{1}].# *Cause*:
Attempt to use an invalid@Column annotation by the entity class
ClassName to map its relationship attribute attribute.

*Action*: Ensure the entity class ClassName uses a @JoinColumn attribute
instead of a @Column attribute to map its relationship attribute
attributeName.

[.msg]#ECLIPSELINK-07158: Error encountered when building the
@NamedQuery [\{1}] from entity class [\{0}].# *Cause*: Error encountered
when building the @NamedQuery annotation from entity class ClassName.

*Action*: Ensure the correctness of the annotation specification.

[.msg]#ECLIPSELINK-07159: The map key [\{0}] on the entity class [\{1}]
could not be found for the mapping [\{2}].# *Cause*: Invalid use of an
unnamed @NamedQuery annotation with the query string string by an entity
class ClassName .

*Action*: Specify a name for @NamedQuery.

[.msg]#ECLIPSELINK-07160: @OneToMany for attribute name [\{1}] in entity
class [\{0}] should not have @JoinColumn(s) specified. In the case where
the @OneToMany is not mapped by another entity (that is, it is the
owning side and is uni-directional), it should specify (optional through
defaulting) a @JoinTable.# *Cause*: @OneToMany annotation for attribute
attributeName in entity class ClassName has both an @AssocationTable and
@JoinColumn(s) annotations specified.

*Action*: Specify one annotation only: @AssocationTable or
@JoinColumn(s).

[.msg]#ECLIPSELINK-07161: Entity class [\{0}] has no primary key
specified. It should define either an @Id, @EmbeddedId or an @IdClass.
If you have defined PK using any of these annotations then please make
sure that you do not have mixed access-type (both fields and properties
annotated) in your entity class hierarchy.# *Cause*: Primary key
annotation is not specified for the entity class ClassName.

*Action*: Define either an @Id, @EmbeddedId or an @IdClass annotation.

[.msg]#ECLIPSELINK-07162: Entity class [\{0}] has multiple @EmbeddedId’s
specified (on attributes [\{1}] and [\{2}]). Only one @EmbeddedId can be
specified per entity.# *Cause*: Multiple @EmbeddedId annotations are
specified (on attributeName and differentAttributeName) for entity class
ClassName.

*Action*: Specify only one @EmbeddedId annotation for this entity.

[.msg]#ECLIPSELINK-07163: Entity class [\{0}] has both an @EmbdeddedId
(on attribute [\{1}]) and an @Id (on attribute [\{2}]. Both id types
cannot be specified on the same entity.# *Cause*: Entity class ClassName
has both an @EmbdeddedId (on attribute attributeName) and an @Id (on
attribute differentAttributeName).

*Action*: Specify only one ID type on this entity: either @EmbdeddedId
or @Id.

[.msg]#ECLIPSELINK-07164: The type [\{1}] for the attribute [\{0}] on
the entity class [\{2}] is not a valid type for a lob mapping. For a lob
of type BLOB, the attribute must be defined as a java.sql.Blob, byte[],
Byte[] or a Serializable type. For a lob of type CLOB, the attribute
must be defined as a java.sql.Clob, char[], Character[] or String type.#
*Cause*: Attribute attributeName in an entity class ClassName has an
invalid type for a @Lob annotation of type BLOB.

*Action*: Define this attribute as a java.sql.Blob, byte[], Byte[] or a
Serializable type.

[.msg]#ECLIPSELINK-07165: The type [\{1}] for the attribute [\{0}] on
the entity class [\{2}] is not a valid type for a temporal mapping. The
attribute must be defined as java.util.Date or java.util.Calendar.#
*Cause*: Attribute attributeName in entity class ClassName has an
invalid type for a @Lob annotation of type CLOB.

*Action*: Define this attribute as a java.sql.Clob, char[], Character[]
or String type.

[.msg]#ECLIPSELINK-07166: A table generator that uses the reserved name
[\{0}] for its '`name`' has been found in [\{1}]. It cannot use this
name since it is reserved for defaulting a sequence generator’s
'`sequence name`'.# *Cause*: Conflict between annotations @Annotation
and @DifferentAnnotation.

*Action*: Ensure that these two annotations are not conflicting.

[.msg]#ECLIPSELINK-07167: A sequence generator that uses the reserved
name [\{0}] for its '`sequence name`' has been found in [\{1}]. It
cannot use this name since it is reserved for defaulting a table
generator’s '`name`'.# *Cause*: Attempt to use a reserved annotation
name AnnotationName by an entity class ClassName: cannot use this name,
because it is reserved for name.

*Action*: Specify a different name for this annotation.

[.msg]#ECLIPSELINK-07168: The attribute [\{0}] of type [\{1}] on the
entity class [\{2}] is not valid for a version property. The following
types are supported: int, Integer, short, Short, long, Long, Timestamp.#
*Cause*: Attempt to specify a generator with type Type by an annotation
@Annotation.

*Action*: Ensure that this annotation specifies a generator of a
different type.

[.msg]#ECLIPSELINK-07169: Class [\{0}] has two @GeneratedValues: for
fields [\{1}] and [\{2}]. Only one is allowed.# *Cause*: The callback
method methodName on the entity listener ListenerClassName has an
incorrect signature.

*Action*: Provide only one parameter of type Object for this method.

[.msg]#ECLIPSELINK-07172: Error encountered when instantiating the class
[\{0}].# *Cause*: EclipseLink was unable to instantiate the entity
listener using the @EntityListener annotation.

*Action*: Ensure that the annotation is correctly specified.

[.msg]#ECLIPSELINK-07173: A property change event has been fired on a
property with name [\{1}] in [\{0}]. However this property does not
exist.# *Cause*: Attempt to fire a property change event on a
nonexisting property propertyName in a change event EventClassName.

*Action*: Ensure that this property exists.

[.msg]#ECLIPSELINK-07174: The getter method [\{1}] on entity class
[\{0}] does not have a corresponding setter method defined.# *Cause*:
The getter method methodName on an entity class ClassName does not have
a corresponding setter method defined.

*Action*: Define a corresponding setter method.

[.msg]#ECLIPSELINK-07175: The mapping [\{0}] does not support cascading
version optimistic locking.# *Cause*: Attempt to use the mapping
MappingType that does not support cascading version optimistic locking.

*Action*: Use a different mapping.

[.msg]#ECLIPSELINK-07176: The mapping [\{0}] does not support cascading
version optimistic locking because it has a custom query.# *Cause*:
Attempt to use the mapping MappingType that does not support cascading
version optimistic locking. This mapping has a custom query.

*Action*: Use a different mapping.

[.msg]#ECLIPSELINK-07177: The aggregate descriptor [\{0}] has
privately-owned mappings. Aggregate descriptors do not support cascading
version optimistic locking.# *Cause*: Attempt to use an aggregate
descriptor DescriptorName that has privately-owned mappings: aggregate
descriptors do not support cascading version optimistic locking.

*Action*: Use a different descriptor.

[.msg]#ECLIPSELINK-07178: OracleOCIProxyConnector requires
OracleOCIConnectionPool datasource.# *Cause*: Attempt to use invalid
arguments in an entity callback method methodName on a
OracleOCIProxyConnector: it requires the OracleOCIConnectionPool data
source.

*Action*: Provide OracleOCIProxyConnector with the
OracleOCIConnectionPool argument.

[.msg]#ECLIPSELINK-07179: OracleJDBC10_1_0_2ProxyConnector requires
datasource producing OracleConnections.# *Cause*: Attempt to use invalid
arguments in an entity callback method methodName on a
OracleJDBC10_1_0_2ProxyConnector.

*Action*: Provide OracleJDBC10_1_0_2ProxyConnector with data source
producing Oracle Connections.

[.msg]#ECLIPSELINK-07180: OracleJDBC10_1_0_2ProxyConnector requires
Oracle JDBC version 10.1.0.2 or higher so that OracleConnection declares
openProxySession method.# *Cause*: Attempt to use the
OracleJDBC10_1_0_2ProxyConnector with Oracle JDBC version 10.1.0.1 or
earlier: OracleJDBC10_1_0_2ProxyConnector requires Oracle JDBC version
10.1.0.2 or later.

*Action*: Provide OracleJDBC10_1_0_2ProxyConnector with Oracle JDBC
version 10.1.0.2 or later in order for the OracleConnection to declare
the openProxySession method.

[.msg]#ECLIPSELINK-07181: OracleJDBC10_1_0_2ProxyConnector requires
'`’proxytype`'’ property to be an int converted to String, for instance
Integer.toString(OracleConnection.PROXYTYPE_USER_NAME)# *Cause*: Attempt
to use an invalid type for the proxytype property on the
OracleJDBC10_1_0_2ProxyConnector: it requires the proxytype property to
be an int converted to a String.

*Action*: On the OracleJDBC10_1_0_2ProxyConnector, provide the proxytype
property of type int converted to a String. For example,
Integer.toString(OracleConnection.PROXYTYPE_USER_NAME).

[.msg]#ECLIPSELINK-07182: EC - Could not find driver class [\{0}]#
*Cause*: EclipseLink could not find the driver class.

*Action*: Ensure that the driver class exists and is on the classpath.

[.msg]#ECLIPSELINK-07183: Error closing persistence.xml file.# *Cause*:
EclipseLink cannot close persistence.xml file.

*Action*: If you modified the persistence.xml, ensure that this file is
not read-only.

[.msg]#ECLIPSELINK-07184: [\{0}] system property not specified. It must
be set to a class that defines a '`’getContainerConfig()`'’ method.#
*Cause*: The system property propertyName is not specified.

*Action*: Set this property to a class that defines a
getContainerConfig() method.

[.msg]#ECLIPSELINK-07185: Cannot find class [\{0}] specified in [\{1}]#
*Cause*: EclipseLink cannot find class ClassName.

*Action*: Ensure that the class exists and is properly specified.

[.msg]#ECLIPSELINK-07186: Cannot invoke method [\{0}] on class [\{1}]
specified in [\{2}]# *Cause*: EclipseLink cannot invoke method
methodName on configuration class ClassName.

*Action*: Ensure that this method exists in this class.

[.msg]#ECLIPSELINK-07187: [\{0}] should define a public static method
[\{1}] that has no parameters and returns Colleciton# *Cause*: Class
ClassName does not define a public static method methodName.

*Action*: In the class ClassName, define a public static method
methodName that has no parameters and returns a Collection.

[.msg]#ECLIPSELINK-07188: Non-null class list is required.# *Cause*:
Class list is null.

*Action*: Provide a non-null class list.

[.msg]#ECLIPSELINK-07189: Cannot create temp classloader from current
loader: [\{0}]# *Cause*: EclipseLink cannot create a temporary class
loader from the current loader ClassLoaderName.

*Action*: Ensure the validity of the current class loader.

[.msg]#ECLIPSELINK-07190: [\{0}] failed# *Cause*: Failure in the
execution of the methodName method.

*Action*: Ensure the correctness of the method.

[.msg]#ECLIPSELINK-07191: The entity class [\{0}] was not found using
class loader [\{1}].# *Cause*: An entity class ClassName was not found
using class loader ClassLoaderName.

*Action*: Ensure that the entity class exists and is on the classpath.

[.msg]#ECLIPSELINK-07192: ClassFileTransformer [\{0}] throws an
exception when performing transform() on class [\{1}].# *Cause*: Class
file transformer TransformerName threw an exception when performing
transform() method on class ClassName.

*Action*: Ensure the correctness of the transform() method. Check the
internal exception for details on the root cause of this exception

[.msg]#ECLIPSELINK-07193: Jar files in persistence XML are not supported
in this version of EclipseLink.# *Cause*: Attempt to use JAR files in
the persistence.xml file: JAR files are not supported in this version of
Toplink.

*Action*: Do not use JAR files.

[.msg]#ECLIPSELINK-07194: Could not bind: [\{0}] to: [\{1}].# *Cause*:
Attempt to use an unsupported method setFlushMode().

*Action*: Do not use this method.

[.msg]#ECLIPSELINK-07195: Exception configuring EntityManagerFactory.#
*Cause*: EclipseLink could not bind name to anotherName.

*Action*: Ensure the correct use of this binding.

[.msg]#ECLIPSELINK-07196: [\{0}] of type [\{1}] cannot be casted to
[\{2}].# *Cause*: Exception configuring EntityManagerFactory.

*Action*: Ensure the correct configuration of this factory class. Check
the internal exception for details on the root cause of this exception

[.msg]#ECLIPSELINK-07197: This operation is not supported for this
class: [\{0}], [\{1}].# *Cause*: EclipseLink could not calculate
changes, because the primary key is set to null.

*Action*: Set the primary key to a non-null value.

[.msg]#ECLIPSELINK-07198: Class: [\{0}] was not found while converting
from class names to classes.# *Cause*: Attempt to cast an instance of
class ClassName to AnotherClassName. This is an invalid cast.

*Action*: Provide a valid cast.

[.msg]#ECLIPSELINK-07199: A primary table was not defined for entity
\{0} in the entity-mappings file: \{1}. A primary table is required to
process an entity relationship.# *Cause*: An attribute attributeName in
an entity class ClassName has a mappedBy value of value. This value does
not exist in its owning entity class ClassName.

*Action*: If the owning entity class is an @EmbeddableSuperclass, this
is invalid. Make your attribute reference the correct subclass.

[.msg]#ECLIPSELINK-07200: The attribute [\{1}] was not found on the
embeddable class [\{0}]. It is referenced in the @AttributeOverride for
the @Embedded attribute [\{3}] on class [\{2}].# *Cause*: Either name or
referencedColumnName element is not specified: if there is more than one
join column, both the name and the referencedColumnName elements must be
specified in each @JoinColumn annotation.

*Action*: Ensure that both the name and the referencedColumnName
elements are specified in each @JoinColumn annotation.

== Session Loader Exceptions (9000 - 9010)

`+SessionLoaderException+` is a run-time exception that is raised if the
session manager encounters a problem loading session information from a
`+sessions.xml+` (for non-EJB applications)

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-9]##*_Session Loader Exception_*

`+EXCEPTION [ECLIPSELINK – 9004]: org.eclipse.persistence.exceptions.SessionLoaderException+`
`+EXCEPTION DESCRIPTION: The +``+ file MyProject was not found +`
`+on the classpath, nor on the filesystem.+`

[.msg]#ECLIPSELINK-09000: Several [\{0}] SessionLoaderExceptions were
thrown:# *Cause*: The session loader caught one or more XML parsing
exceptions while loading session information. The specific XML
exceptions follow.

*Action*: Verify your session configuration XML file.

[.msg]#ECLIPSELINK-09001: Unknown tag name: [\{0}] in XML node: [\{1}].#
*Cause*: An unknown tag was encountered in the specified XML node.

*Action*: Examine the specified XML node in your session configuration
XML file. Ensure that you use only the tags defined for that node in the
appropriate EclipseLink XSD. See the directory where you installed
EclipseLink (for example, /toplink/config/xsds)

[.msg]#ECLIPSELINK-09002: Unable to load Project class [\{0}].# *Cause*:
The specified class loader could not load a class with the name given by
the project-name property.

*Action*: Verify the value of the project-name property and if correct,
ensure that a class with that name is in your classpath.

[.msg]#ECLIPSELINK-09003: Unable to process XML tag [\{0}] with value
[\{1}].# *Cause*: The session loader caught an exception while either
parsing the value of the specified tag or calling the setter method
associated with the specified tag.

*Action*: Verify the value shown for the specified tag.

[.msg]#ECLIPSELINK-09004: The project-xml file [\{0}] was not found on
the classpath, nor on the filesystem.# *Cause*: The session loader could
not find the file identified by the project-xml tag on either the
classpath or the file system.

*Action*: Verify the value of the project-xml tag and if correct, ensure
that a project.xml file with that name exists in your classpath or file
system.

[.msg]#ECLIPSELINK-09005: An exception was thrown while loading the
project-xml file [\{0}].# *Cause*: The session loader caught an
exception while trying to load the file identified by the project-xml
tag either because the file could not be found, or because the file
could not be parsed.

*Action*: Verify the configuration of the project XML file and ensure
that a project.xml file with that name specified by the project-xml tag
exists in your classpath or file system.

[.msg]#ECLIPSELINK-09006: A \{0} was thrown while parsing the XML file.
It occurs at line \{1} and column \{2} in the XML document.# *Cause*:
The session loader caught a SAX exception while trying to parse the XML
at the given line and column of the specified XML file. EclipseLink 10g
supports only UTF-8 encoding. The EclipseLink SAXParseException occurs
if you attempt to read a non-UTF-8 formatted XML file.

*Action*: Verify that the XML is correctly formatted at the given line
and column. Alternatively, ensure the Oracle parser is in your classpath
and that it appears before any other XML parser.

[.msg]#ECLIPSELINK-09007: An exception was thrown while parsing the XML
file.# *Cause*: The session loader caught an exception unrelated to XML
parsing (for example, a premature end-of-file exception) while trying to
parse the specified XML file.

*Action*: Verify the integrity of the XML file.

[.msg]#ECLIPSELINK-09008: Unexpected value [\{0}] of tag [\{1}].#
*Cause*: The value of an XML tag does not correspond to any known
EclipseLink required values.

*Action*: Please verify the list of values for this tag.

[.msg]#ECLIPSELINK-09009: Tag [\{0}] has unknown attribute.# *Cause*:
There is an incorrect name value pair when processing transport
properties for the XSD tag.

*Action*: Please verify that all properties have both the name and the
value filled in, in the session configuration XML file.

[.msg]#ECLIPSELINK-09010: A \{0} was thrown while parsing the XML file
against the XML schema.# *Cause*: An exception was raised while parsing
the XML file against the XML schema.

*Action*: Examine the exception and take the appropriate action.

== Communication Exceptions (12000 - 12003)

`+CommunicationException+` is a run-time exception that wraps all RMI,
CORBA, or input and output exceptions that occur.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-11]##*_Communication Exception_*

`+EXCEPTION [ECLIPSELINK – 12000]: org.eclipse.persistence.exceptions.CommunicationException+`
`+EXCEPTION DESCRIPTION: Error Sending connection service to myService.+`

[.msg]#ECLIPSELINK-12000: Error Sending connection service to \{0}.#
*Cause*: Failed to add a connection to CacheSynchronizationManager or
RemoteCommandManager.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-12001: Unable to Connect to \{0}.# *Cause*:
CacheSynronizationManager failed to connect to the specified service.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-12002: Unable to propagate changes to \{0}.# *Cause*:
CacheSynronizationManager failed to propagate changes to the specified
service.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-12003: Error in invocation: \{0}.# *Cause*: Error
invoking a remote call.

*Action*: See the generated exception for the root cause.

== EIS Exceptions (17007 – 17025), 90000, 91000

`+EISException+` is a run-time exception that is raised when invoking
EIS interactions. For more information on EIS interactions, see
link:Introduction_to_EclipseLink_Queries_(ELUG)#Enterprise_Information_System_(EIS)_Interactions[Enterprise
Information System (EIS) Interactions].

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-12]##*_JMS Processing Exception_*

`+EXCEPTION [ECLIPSELINK – 17010]: org.eclipse.persistence.eis.EISException+`
`+EXCEPTION DESCRIPTION: Output record contains an unsupported message type.+`

[.msg]#ECLIPSELINK-17007: \{0} property must be set.# *Cause*: The
specified property is not set.

*Action*: Verify your interaction and ensure that the specified property
is set (see "`Configuring Custom EIS Interactions for Basic Persistence
Operations`" on page 73-6 or "`Creating an EIS Interaction for a Named
Query`" on page 116-26).

[.msg]#ECLIPSELINK-17008: Invalid \{0} property encountered.# *Cause*:
Invalid property encountered.

*Action*: Verify your interaction and remove the specified property (see
"`Configuring Custom EIS Interactions for Basic Persistence Operations`"
on page 73-6 or "`Creating an EIS Interaction for a Named Query`" on
page 116-26).

[.msg]#ECLIPSELINK-17009: \{0} or \{1} property must be set.# *Cause*:
The specified properties are not set.

*Action*: Verify your interaction and ensure that the specified
properties are set (see "`Configuring Custom EIS Interactions for Basic
Persistence Operations`" on page 73-6 or "`Creating an EIS Interaction
for a Named Query`" on page 116-26).

[.msg]#ECLIPSELINK-17010: Output record contains an unsupported message
type# *Cause*: The output record contains an unsupported message type.

*Action*: Verify your interaction and ensure that you specify a
supported message type. Ensure that the required connector JAR file is
on your classpath (see "`EIS Project Concepts`" on page 68-1).

[.msg]#ECLIPSELINK-17011: No connection factory has been specified.#
*Cause*: The connection factory is not specified.

*Action*: Verify your interaction and ensure that you specify a
connection factory (see "`Configuring EIS Connection Specification
Options at the Project Level`" on page 70-3 or "`Configuring EIS
Connection Specification Options at the Session Level`" on page 96-2 ).

[.msg]#ECLIPSELINK-17012: InteractionSspec must be a
CciJMSInteractionSpec.# *Cause*: InteractionSpec is not a
CciJMSInteractionSpec.

*Action*: Verify your interaction and ensure that you specify a valid
interaction specification type (CciJMSInteractionSpec). Ensure that the
required connector JAR file is on your classpath (see "`EIS Project
Concepts`" on page 68-1).

[.msg]#ECLIPSELINK-17013: Record must be a CciJMSRecord.# *Cause*:
Record is not a CciJMSRecord.

*Action*: Verify your interaction and ensure that you specify a valid
record type (CciJMSRecord). Ensure that the required connector JAR file
is on your classpath (see "`EIS Project Concepts`" on page 68-1).

[.msg]#ECLIPSELINK-17014: Unknown interaction specification type#
*Cause*: Unknown interaction specification type.

*Action*: Verify your interaction and ensure that you specify a valid
interaction specification type. Ensure that the required connector JAR
file is on your classpath (see "`EIS Project Concepts`" on page 68-1).

[.msg]#ECLIPSELINK-17015: Input must contain a single text element.#
*Cause*: Invalid input: input must contain a single text element.

*Action*: Verify your interaction and ensure that you specify valid
input-a single text element (see "`Configuring Custom EIS Interactions
for Basic Persistence Operations`" on page 73-6 or "`Creating an EIS
Interaction for a Named Query`" on page 116-26).

[.msg]#ECLIPSELINK-17016: A timeout occurred - no message was received.#
*Cause*: A time-out occurred-no message was received.

*Action*: Verify your interaction and the EIS on which you invoked it.

[.msg]#ECLIPSELINK-17017: Input record contains an unsupported message
type.# *Cause*: Input record contains an unsupported message type.

*Action*: Verify your interaction and ensure that you specify a valid
message type. Ensure that the required connector JAR file is on your
classpath (see "`EIS Project Concepts`" on page 68-1).

[.msg]#ECLIPSELINK-17018: Cannot invoke "`begin()`" on a non-transacted
session.# *Cause*: EclipseLink cannot invoke begin method on a
nontransacted session.

*Action*: To be determined.

[.msg]#ECLIPSELINK-17019: Problem testing for transacted session:#
*Cause*: Problem testing for transacted session.

*Action*: To be determined.

[.msg]#ECLIPSELINK-17020: InteractionSspec must be an
AQInteractionSpec.# *Cause*: InteractionSpec is not an
AQInteractionSpec.

*Action*: Verify your interaction and ensure that you specify a valid
Oracle AQ interaction specification type (AQInteractionSpec). Ensure
that the required connector JAR file is on your classpath (see "`EIS
Project Concepts`" on page 68-1).

[.msg]#ECLIPSELINK-17021: Record must be an AQRecord.# *Cause*: Record
is not an AQRecord.

*Action*: Verify your interaction and ensure that you specify a valid
Oracle AQ record type (AQRecord). Ensure that the required connector JAR
file is on your classpath (see "`EIS Project Concepts`" on page 68-1).

[.msg]#ECLIPSELINK-17022: Input must contain a single raw element.#
*Cause*: Invalid input: input must contain a single raw element.

*Action*: Verify your Oracle AQ interaction and ensure that you specify
valid input-a single raw element (see "`Configuring Custom EIS
Interactions for Basic Persistence Operations`" on page 73-6 or
"`Creating an EIS Interaction for a Named Query`" on page 116-26).

[.msg]#ECLIPSELINK-17023: An exception occurred setting
MQQueueConnectionFactory attributes.# *Cause*: An exception occurred
setting MQQueueConnectionFactory attributes.

*Action*: Verify your interaction and ensure that you specify an
appropriate IBM MQSeries connection factory (see "`Configuring EIS
Connection Specification Options at the Project Level`" on page 70-3 or
"`Configuring EIS Connection Specification Options at the Session
Level`" on page 96-2).

[.msg]#ECLIPSELINK-17024: Could not delete file: \{0}# *Cause*:
EclipseLink cannot delete the specified file.

*Action*: To be determined.

[.msg]#ECLIPSELINK-17025: This mapping requires a foreign key grouping
element, as mulitple foreign keys exist.# *Cause*: No grouping element
is specified: this mapping requires a foreign key grouping element, as
mulitple foreign keys exist.

*Action*: Verify your EIS mappings (see Chapter 74, "`Introduction to
EIS Mappings`".

== Discovery Exceptions (22001 - 22004)

`+DiscoveryException+` is a run-time exception that is raised when
`+DiscoveryManager+` is operating.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-15]##*_Discovery Exception_*

`+EXCEPTION [ECLIPSELINK – 22001]: org.eclipse.persistence.exception.DiscoveryException+`
`+EXCEPTION DESCRIPTION: Could not join multicast group.+`

[.msg]#ECLIPSELINK-22001: Could not join multicast group# *Cause*:
DiscoveryManager failed to join a multicast group due to a
java.io.IOException: either a MulticastSocket could not be created, or
the invocation of the joingGroup method of the MulticastSocket failed.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-22002: Could not send service announcement# *Cause*:
DiscoveryManager failed to inform other services that its service had
started up.

*Action*: Consider increasing the announcement delay: the amount of time
in milliseconds that the service should wait between the time that this
remote service is available and a session announcement is sent out to
other discovery managers. This may be needed to give some systems more
time to post their connections into the naming service. See the
setAnnouncementDelay method of the DiscoveryManager.

[.msg]#ECLIPSELINK-22003: Failed doing lookup of local host# *Cause*:
DiscoveryManager failed to do the lookup of a local host.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-22004: Failed trying to receive a service
announcement from a remote service# *Cause*: DiscoveryManager caught a
java.io.IOException while blocking for announcements from other
DiscoveryManagers.

*Action*: See the generated exception for the root cause.

== Remote Command Manager Exceptions (22101 - 22111)

`+RemoteCommandManagerException+` is a run-time exception that is raised
when the remote command module is used.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-16]##*_Remote Command Manager Exception_*

`+EXCEPTION [ECLIPSELINK – 22104]: org.eclipse.persistence.exceptions.RemoteCommandManagerException+`
`+EXCEPTION DESCRIPTION: Could not look up host name.+`

[.msg]#ECLIPSELINK-22101: Could not obtain JNDI context with properties
\{0}# *Cause*: Failure to get a JNDI context with the specified
properties due to a javax.naming.NamingException.

*Action*: See the generated exception for root cause. Verify that the
properties for looking up the context are correct.

[.msg]#ECLIPSELINK-22102: Could not post connection in local naming
service under name \{0}# *Cause*: Failure to post a connection in the
local naming service with the name serviceName.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-22103: Could not look up remote connection under name
\{0} with URL \{1}# *Cause*: Failure to look up a remote connection with
the specified name and URL.

*Action*: See the generated exception for the root cause. Verify that
the remote connection and URL are correct.

[.msg]#ECLIPSELINK-22104: Could not look up hostname# *Cause*: The
getLocalHost method of the java.net.InetAddress failed to look up the
specified host name.

*Action*: See the generated exception for the root cause. Verify that
the host is online and reachable.

[.msg]#ECLIPSELINK-22105: Could not propagate command to \{0}# *Cause*:
Failure to propagate a command to the specified connection.

*Action*: See the generated exception for the root cause. Verify that
the remote host of the specified connection is online and reachable if
the generated exception included a CommunicationException.

[.msg]#ECLIPSELINK-22106: Could not create external JMS connection with
Topic \{0}, Topic Factory \{1}, and Context properties \{2}# *Cause*:
Failure to create JMS connection with Topic, Topic Factory, and Context
properties.

*Action*: Verify that the JMS Topic is configured correctly with the
application server and the specified Topic. Topic Factory and Context
properties info can be used by a Java client to the JMS Topic.

[.msg]#ECLIPSELINK-22107: Could not remove local connection in local
naming service under name \{0}# *Cause*: Failure to establish a remove
local connection in local naming service under name.

*Action*: Restart the application server or use the application server
tool to remove name from its JNDI if this tool is available.

[.msg]#ECLIPSELINK-22108: Could not serialize or desiralize command#
*Cause*: Failure to serialize or deserialize command.

*Action*: If the command is a user defined command, make sure it is
serializable. If it is an EclipseLink command, file a bug report
including the stack trace.

[.msg]#ECLIPSELINK-22109: Failed to receive JMS message from JMS
provider# *Cause*: Failure to receive JMS message from JMS provider.

*Action*: Make sure that EclipseLink sessions are the only publishers to
the JMS Topic and that the EclipseLink sessions use the same project.

[.msg]#ECLIPSELINK-22110: Failed to discover local host IP address.#
*Cause*: Failure to discover local host IP address.

*Action*: Replace the $HOST string of the URL with the known host name
or IP address.

[.msg]#ECLIPSELINK-22111: Failed to get ServerPlatform. The
ServerPlatform must be set either on Session or RemoteCommandManager.#
*Cause*: Failure to get server platform. The server platform must be set
on Session or RemoteCommandManager.

*Action*: Set the correct ServerPlatform on the RemoteCommandManager.
This exception is raised when the user does not use an EclipseLink
Session and implements the CommandProcessor.

== Transaction Exceptions (23001 - 23015)

`+TransactionException+` is a run-time exception that is raised when an
error is encountered during a transaction. When this occurs, the message
contains a reference to the error code and error message.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-17]##*_Transaction Exception_*

`+EXCEPTION [ECLIPSELINK – 23001]: org.eclipse.persistence.exceptions.TransactionException+`
`+EXCEPTION DESCRIPTION: Error looking up external Transaction resource under JNDI name.+`

[.msg]#ECLIPSELINK-23001: Error looking up external Transaction resource
under JNDI name [\{0}]# *Cause*: Error looking up external transaction
resource under JNDI name name.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23002: Error obtaining status of current externally
managed transaction# *Cause*: Error obtaining the status of the current
externally-managed transaction.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23003: Error obtaining current externally managed
transaction# *Cause*: Error obtaining the current externally managed
transaction.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23004: Error obtaining the Transaction Manager#
*Cause*: Error obtaining the transaction manager.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23005: Error binding to externally managed
transaction# *Cause*: Error binding to the externally managed
transaction.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23006: Error beginning new externally managed
transaction# *Cause*: Error beginning a new externally managed
transaction.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23007: Error committing externally managed
transaction# *Cause*: Error committing the externally managed
transaction.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23008: Error rolling back externally managed
transaction# *Cause*: Error rolling back the externally managed
transaction.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23009: Error marking externally managed transaction
for rollback# *Cause*: Error marking the externally managed transaction
for rollback.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23010: No externally managed transaction is currently
active for this thread# *Cause*: No externally managed transaction is
currently active for this thread.

*Action*: Ensure that the transaction is still active.

[.msg]#ECLIPSELINK-23011: UnitOfWork [\{0}] was rendered inactive before
associated externally managed transaction was complete.# *Cause*: A
UnitOfWork was rendered inactive before the associated externally
managed transaction was complete.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23012: No transaction is currently active# *Cause*:
Attempt to use an EntityTransaction while using JTA. This is an invalid
operation.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23013: Transaction is currently active# *Cause*:
Attempt to enlist multiple data sources in the transaction.

*Action*: Enlist only one data source per transaction.

[.msg]#ECLIPSELINK-23014: Cannot use an EntityTransaction while using
JTA.# *Cause*: Exception occurred in Proxy execution.

*Action*: Examine the internal exception and take the appropriate
action.

[.msg]#ECLIPSELINK-23015: Cannot enlist multiple datasources in the
transaction.# *Cause*: No entity transaction is currently active for
this thread.

*Action*: Ensure that the transaction is active.

== XML Marshal Exceptions (25001 – 25020)

`+XMLMarshalException+` is raised when an error is encountered during
the XML marshalling process.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-19]##*_XML Marshal Exception_*

`+EXCEPTION [ECLIPSELINK – 25001]: org.eclipse.persistence.exceptions.XMLMarshalException+`
`+EXCEPTION DESCRIPTION: Error while trying to create session.+`

[.msg]#ECLIPSELINK-25001: Invalid XPath string: \{0}# *Cause*: Attempt
to use an invalid XPath string.

*Action*: Ensure that the XPath is specified correctly.

[.msg]#ECLIPSELINK-25002: An integer index could not be parsed from this
XPath string: \{0}# *Cause*: An integer index could not be parsed from
this XPath string.

*Action*: Update any XPath strings that contain an index, and ensure
that only a single integer value is contained between the square braces.

[.msg]#ECLIPSELINK-25003: An error occurred marshalling the object#
*Cause*: An error occurred marshalling the object.

*Action*: Check the nested exception to determine the cause of the
problem. Typically, there is a problem with the object being written.

[.msg]#ECLIPSELINK-25004: An error occurred unmarshalling the document#
*Cause*: An error occurred unmarshalling the document.

*Action*: Check the nested exception to determine the cause of the
problem. Typically, there is a problem with the XML document being read.

[.msg]#ECLIPSELINK-25005: An error occurred validating the object#
*Cause*: An error occurred validating the object.

*Action*: The XML generated from the object is invalid according to the
schema. Ensure that any values set in the domain classes do not violate
any schema constraints when marshalled.

[.msg]#ECLIPSELINK-25006: A default root element was not specified for
the XMLDescriptor mapped to \{0}# *Cause*: A default root element is not
specified for the XMLDescriptor mapped to target.

*Action*: Specify the default root element for the descriptor.

[.msg]#ECLIPSELINK-25007: A descriptor for class \{0} was not found in
the project# *Cause*: A descriptor for a class was not found in the
project.

*Action*: Make sure that any classes referenced through CompositeObject
and/or CompositeCollection mappings have descriptors in the project.

[.msg]#ECLIPSELINK-25008: A descriptor with default root element \{0}
was not found in the project# *Cause*: A descriptor with a default root
element was not found in the project.

*Action*: Set a default root element on any descriptor that maps to the
root of a document. Make sure that the root element of the XML document
being read in is mapped to a descriptor in the project.

[.msg]#ECLIPSELINK-25010: A schema reference was not specified for the
XMLDescriptor mapped to \{0}# *Cause*: A schema reference is not
specified for the XMLDescriptor mapped to target.

*Action*: Specify the schema reference for the descriptor.

[.msg]#ECLIPSELINK-25011: A null argument was encountered# *Cause*: A
null argument was encountered.

*Action*: Ensure that this argument is not null.

[.msg]#ECLIPSELINK-25012: An error occurred resolving the XML Schema.#
*Cause*: An error occurred resolving the XML Schema.

*Action*: Check any schema references and make sure that the schema can
be accessed by the application at runtime.

[.msg]#ECLIPSELINK-25013: An error occurred while trying to set the
schemas.# *Cause*: An error occurred while trying to set the schemas.

*Action*: An error was encountered while attempting to set schemas on an
XML parser. Check the nested exception to determine the correct course
of action.

[.msg]#ECLIPSELINK-25014: An error occurred while trying to instantiate
the schema platform.# *Cause*: An error occurred while trying to
instantiate the schema platform.

*Action*: An error was encountered while instantiating the schema
platform. Check the nested exception to determine the correct course of
action.

[.msg]#ECLIPSELINK-25015: An error occurred trying to resolve the
namespace URI for \{0}. A namespace resolver was not specified on the
descriptor.# *Cause*: An error occurred while trying to resolve the
namespace URI for a target. A namespace resolver was not specified on
the descriptor.

*Action*: Ensure that any descriptors that make use of namespaces have a
namespace resolver specified on them.

[.msg]#ECLIPSELINK-25016: A namespace for the prefix \{0} was not found
in the namespace resolver.# *Cause*: A namespace for the prefix was not
found in the namespace resolver.

*Action*: Ensure that any namespace prefix which is used by a descriptor
or mapping has a corresponding entry in that descriptor’s namespace
resolver.

[.msg]#ECLIPSELINK-25017: Either enumClass or enumClassName must be set
on the JAXBTypesafeEnumConverter.# *Cause*: Enumeration class is not
specified.

*Action*: Set either enumClass or enumClassName on the
JAXBTypesafeEnumConverter.

[.msg]#ECLIPSELINK-25018: The fromString method on the enum class \{0}
does not exist or could not be invoked.# *Cause*: Error during the
invocation of the fromString method on the enumeration class ClassName:
the method does not exist or could not be invoked.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-25019: The specified enum class \{0} could not be
found.# *Cause*: The specified enumeration class ClassName was not
found.

*Action*: Ensure the correct specification of the enumeration class.

[.msg]#ECLIPSELINK-25020: The method getResult() must not be called
before the endDocument() event has been called.# *Cause*: Attempt to
call the method getResult before the call to the endDocument event.

*Action*: Call the getResult method after the endDocument event has been
called.

== XML Conversion Exceptions (25501)

`+XMLConversionException+` is a run-time exception that is raised when a
conversion between EclipseLink instances and XML fails. This exception
is used in cache coordination that uses XML change sets.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-18]##*_XML Conversion Exception_*

`+EXCEPTION [ECLIPSELINK – 25001]: org.eclipse.persistence.exceptions.XMLConversionException+`
`+EXCEPTION DESCRIPTION: Cannot create URL for file  [\\FILE_SERVER\command.xml].+`

[.msg]#ECLIPSELINK-25501: Cannot create URL for file [\{0}] .# *Cause*:
Failure to create a URL for the specified file.

*Action*: Ensure that all specified XPath strings on mappings are valid
and correct.

== XML Platform Exceptions (27001 – 27006, 27101 – 27103, 27201 – 27202)

`+XMLPlatformException+` is raised when an error related to XML platform
is encountered.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-21]##*_EJB JAR XML Exception_*

`+EXCEPTION [ECLIPSELINK – 27001]: org.eclipse.persistence.platform.xml.XMLPlatformException+`
`+EXCEPTION DESCRIPTION: The XML platform class ClassName was not found.+`

[.msg]#ECLIPSELINK-27001: The XML Platform class was not found: \{0}#
*Cause*: The XML platform class ClassName was not found.

*Action*: Ensure that this class is on the classpath.

[.msg]#ECLIPSELINK-27002: The XML Platform could not be instantiated:
\{0}# *Cause*: Failure to instantiate the XML platform ClassName.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-27003: A new XML document could not be created.#
*Cause*: The XML platform failed to create a new XML document.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-27004: The XPath was invalid.# *Cause*: The XPath is
invalid.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-27005: An error occurred while validating the
document.# *Cause*: Error during the document validation.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-27006: Could not resolve XML Schema: \{0}# *Cause*:
Failure to resolve an XML Schema schema: XML platform parser error
occurred.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-27101: An error occurred while parsing the document.#
*Cause*: Failure to parse the document.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-27102: File not found: [\{0}]# *Cause*: Failure to
find the XML platform parser file.

*Action*: Ensure that the parser file exists and is accessible (on the
classpath).

[.msg]#ECLIPSELINK-27103: ** Parsing error, line [\{0}], uri [\{1}]
[\{2}]# *Cause*: SAX parser error at line lineNumber, URI uri.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-27201: An error occurred while transforming the
document.# *Cause*: Error during the transforming of the document.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-27202: Unknown type encountered: \{0}# *Cause*:
Unknown type type encountered.

*Action*: See the generated exception for the root cause.

== Entity Manager Setup Exceptions (28001 – 28007)

`+EntityManagerSetupException+` is raised when an error is encountered
during the process of setting up an entity manager.

*_Format_*

`+EXCEPTION [ECLIPSELINK – error code]: Exception name+`
`+EXCEPTION DESCRIPTION: Message+`

[#Example A-22]##*_Entity Manager Setup Exception_*

`+EXCEPTION [ECLIPSELINK – 28001]: org.eclipse.persistence.exceptions.EntityManagerSetupException+`
`+EXCEPTION DESCRIPTION: Error while trying to create session.+`

[.msg]#ECLIPSELINK-28001: A ValidationException was thrown while trying
to create session: [\{0}] . The most likely causes of this issue are
that your [\{1}] file is not available on the classpath or it does not
contain a session called: [\{0}].# *Cause*: A ValidationException was
thrown while trying to create a session sessionName.

*Action*: Ensure that your fileName file is on the classpath. If it is
on the classpath, ensure that this file contains the session
sessionName.

[.msg]#ECLIPSELINK-28002: EclipseLink is attempting to load a
ServerSession named [\{0}] from [\{1}], and not getting a
ServerSession.# *Cause*: Failure to load a ServerSession sessionName
from sourceName.

*Action*: Ensure that the server session’s type is correct.

[.msg]#ECLIPSELINK-28003: EclipseLink has loaded Session [\{0}] from
[\{1}] and it either does not have a server platform specified or
specifies a server platform that does not use an external transaction
controller. Please specify an appropriate server platform if you plan to
use JTA.# *Cause*: Server platform specification was not found:
EclipseLink has loaded a session sessionName from sourceName, but this
session either does not have a server platform specified, or specifies a
server platform that does not use an external transaction controller.

*Action*: If you plan to use JTA, specify an appropriate server
platform.

[.msg]#ECLIPSELINK-28004: Error in setup of EntityManager factory:
JavaSECMPInitializer.initializeFromMain returned false.# *Cause*: Error
while setting up an
oracle.toplink.sessions.entitymanager.EntityManagerFactory.

*Action*: Ensure the correct setup of the EntityManagerFactory:
initializeFromMain method of the EntityContainer returns true.

[.msg]#ECLIPSELINK-28005: An Exception was thrown in setup of
EntityManager factory.# *Cause*: Error during the setup of
oracle.toplink.sessions.entitymanager.EntityManagerFactory.

*Action*: See the generated exception for the root cause.

[.msg]#ECLIPSELINK-28006: ClassNotFound: [\{0}] specified in [\{1}]
property.# *Cause*: Failure to find the class ClassName specified in the
property propertyName.

*Action*: Ensure that the class exists and is on the classpath.

[.msg]#ECLIPSELINK-28007: Failed to instantiate ServerPlatform of type
[\{0}] specified in [\{1}] property.# *Cause*: Failure to instantiate a
server platform of type ServerPlatformType specified in the property
propertyName.

*Action*: See the generated exception for the root cause.

'''''

_link:EclipseLink_User's_Guide_Copyright_Statement[Copyright Statement]_

Category:_EclipseLink_User's_Guide[Category: EclipseLink User’s Guide]
Category:_Release_1[Category: Release 1]
